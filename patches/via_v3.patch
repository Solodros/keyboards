diff --git a/quantum/dynamic_keymap.c b/quantum/dynamic_keymap.c
index 01be9806e4..d10e8f624f 100644
--- a/quantum/dynamic_keymap.c
+++ b/quantum/dynamic_keymap.c
@@ -278,9 +278,8 @@ void dynamic_keymap_macro_send(uint8_t id) {
     p         = (void *)(DYNAMIC_KEYMAP_MACRO_EEPROM_ADDR);
     void *end = (void *)(DYNAMIC_KEYMAP_MACRO_EEPROM_ADDR + DYNAMIC_KEYMAP_MACRO_EEPROM_SIZE);
     while (id > 0) {
-        // If we are past the end of the buffer, then the buffer
-        // contents are garbage, i.e. there were not DYNAMIC_KEYMAP_MACRO_COUNT
-        // nulls in the buffer.
+        // If we are past the end of the buffer, then there is
+        // no Nth macro in the buffer.
         if (p == end) {
             return;
         }
@@ -290,9 +289,8 @@ void dynamic_keymap_macro_send(uint8_t id) {
         ++p;
     }
 
-    // Send the macro string one or three chars at a time
-    // by making temporary 1 or 3 char strings
-    char data[4] = {0, 0, 0, 0};
+    // Send the macro string by making a temporary string.
+    char data[8] = {0};
     // We already checked there was a null at the end of
     // the buffer, so this cannot go past the end
     while (1) {
@@ -302,14 +300,45 @@ void dynamic_keymap_macro_send(uint8_t id) {
         if (data[0] == 0) {
             break;
         }
-        // If the char is magic (tap, down, up),
-        // add the next char (key to use) and send a 3 char string.
-        if (data[0] == SS_TAP_CODE || data[0] == SS_DOWN_CODE || data[0] == SS_UP_CODE) {
-            data[1] = data[0];
-            data[0] = SS_QMK_PREFIX;
-            data[2] = eeprom_read_byte(p++);
-            if (data[2] == 0) {
-                break;
+        if (data[0] == SS_QMK_PREFIX) {
+            // Get the code
+            data[1] = eeprom_read_byte(p++);
+            // Unexpected null, abort.
+            if (data[1] == 0) {
+                return;
+            }
+            if ( data[1] == SS_TAP_CODE || data[1] == SS_DOWN_CODE || data[1] == SS_UP_CODE ) {
+                // Get the keycode
+                data[2] = eeprom_read_byte(p++);
+                // Unexpected null, abort.
+                if (data[2] == 0) {
+                    return;
+                }
+                // Null terminate
+                data[3] = 0;
+            }
+            else if ( data[1] == SS_DELAY_CODE ) {
+                // Get the number and '|'
+                // At most this is 4 digits plus '|'
+                uint8_t i = 2;
+                while ( 1 ) {
+                    data[i] = eeprom_read_byte(p++);
+                    // Unexpected null, abort
+                    if ( data[i] == 0 ) {
+                        return;
+                    }
+                    // Found '|', send it
+                    if ( data[i] == '|') {
+                        data[i+1] = 0;
+                        break;
+                    }
+                    // If haven't found '|' by i==6 then
+                    // number too big, abort
+                    if ( i == 6 ) {
+                        return;
+                    }
+                    ++i;
+                }
             }
         }
         send_string_with_delay(data, DYNAMIC_KEYMAP_MACRO_DELAY);
diff --git a/quantum/dynamic_keymap.h b/quantum/dynamic_keymap.h
index 459b48d07a..806342efa3 100644
--- a/quantum/dynamic_keymap.h
+++ b/quantum/dynamic_keymap.h
@@ -54,6 +54,12 @@ void dynamic_keymap_set_buffer(uint16_t offset, uint16_t size, uint8_t *data);
 // strings, the last byte must be a null when at maximum capacity,
 // and it not being null means the buffer can be considered in an
 // invalid state.
+//
+// The buffer *may* contain less macro strings than the maximum.
+// This allows a higher maximum number of macros without requiring that
+// number of nulls to be in the buffer.
+// Note: dynamic_keymap_macro_get_count() returns the maximum that *can* be
+// stored, not the current count of macros in the buffer.
 
 uint8_t  dynamic_keymap_macro_get_count(void);
 uint16_t dynamic_keymap_macro_get_buffer_size(void);
diff --git a/quantum/via.c b/quantum/via.c
index 37e2046a10..8dfa015e01 100644
--- a/quantum/via.c
+++ b/quantum/via.c
@@ -22,26 +22,6 @@
 #    error "DYNAMIC_KEYMAP_ENABLE is not enabled"
 #endif
 
-// If VIA_CUSTOM_LIGHTING_ENABLE is not defined, then VIA_QMK_BACKLIGHT_ENABLE is set
-// if BACKLIGHT_ENABLE is set, so handling of QMK Backlight values happens here by default.
-// if VIA_CUSTOM_LIGHTING_ENABLE is defined, then VIA_QMK_BACKLIGHT_ENABLE must be explicitly
-// set in keyboard-level config.h, so handling of QMK Backlight values happens here
-#if defined(BACKLIGHT_ENABLE) && !defined(VIA_CUSTOM_LIGHTING_ENABLE)
-#    define VIA_QMK_BACKLIGHT_ENABLE
-#endif
-
-// If VIA_CUSTOM_LIGHTING_ENABLE is not defined, then VIA_QMK_RGBLIGHT_ENABLE is set
-// if RGBLIGHT_ENABLE is set, so handling of QMK RGBLIGHT values happens here by default.
-// If VIA_CUSTOM_LIGHTING_ENABLE is defined, then VIA_QMK_RGBLIGHT_ENABLE must be explicitly
-// set in keyboard-level config.h, so handling of QMK RGBLIGHT values happens here
-#if defined(RGBLIGHT_ENABLE) && !defined(VIA_CUSTOM_LIGHTING_ENABLE)
-#    define VIA_QMK_RGBLIGHT_ENABLE
-#endif
-
-#if defined(RGB_MATRIX_ENABLE) && !defined(VIA_QMK_RGBLIGHT_ENABLE) && !defined(VIA_CUSTOM_LIGHTING_ENABLE)
-#    define VIA_QMK_RGB_MATRIX_ENABLE
-#endif
-
 #include "quantum.h"
 
 #include "via.h"
@@ -52,22 +32,8 @@
 #include "version.h" // for QMK_BUILDDATE used in EEPROM magic
 #include "via_ensure_keycode.h"
 
-// Forward declare some helpers.
-#if defined(VIA_QMK_BACKLIGHT_ENABLE)
-void via_qmk_backlight_set_value(uint8_t *data);
-void via_qmk_backlight_get_value(uint8_t *data);
-#endif
-
-#if defined(VIA_QMK_RGBLIGHT_ENABLE)
-void via_qmk_rgblight_set_value(uint8_t *data);
-void via_qmk_rgblight_get_value(uint8_t *data);
-#endif
-
 #if defined(VIA_QMK_RGB_MATRIX_ENABLE)
 #    include <lib/lib8tion/lib8tion.h>
-void via_qmk_rgb_matrix_set_value(uint8_t *data);
-void via_qmk_rgb_matrix_get_value(uint8_t *data);
-void eeconfig_update_rgb_matrix(void);
 #endif
 
 // Can be called in an overriding via_init_kb() to test if keyboard level code usage of
@@ -156,6 +122,34 @@ void via_set_layout_options(uint32_t value) {
     }
 }
 
+#if defined(VIA_QMK_AUDIO_ENABLE)
+float via_device_indication_song[][2] = SONG(STARTUP_SOUND);
+#endif
+
+// Used by VIA to tell a device to flash LEDs (or do something else) when that
+// device becomes the active device being configured, on startup or switching
+// between devices. This function will be called six times, at 200ms interval,
+// with an incrementing value starting at zero. Since this function is called
+// an even number of times, it can call a toggle function and leave things in
+// the original state.
+__attribute__((weak)) void via_set_device_indication(uint8_t value) {
+#if defined(VIA_QMK_BACKLIGHT_ENABLE)
+    backlight_toggle();
+#endif  // VIA_QMK_BACKLIGHT_ENABLE
+#if defined(VIA_QMK_RGBLIGHT_ENABLE)
+    rgblight_toggle_noeeprom();
+#endif
+#if defined(VIA_QMK_RGB_MATRIX_ENABLE)
+    rgb_matrix_toggle_noeeprom();
+#endif
+#if defined(VIA_QMK_AUDIO_ENABLE)
+    if ( value == 0 ) {
+        wait_ms(10);
+        PLAY_SONG(via_device_indication_song);
+    }
+#endif
+}
+
 // Called by QMK core to process VIA-specific keycodes.
 bool process_record_via(uint16_t keycode, keyrecord_t *record) {
     // Handle macros
@@ -195,24 +189,91 @@ bool process_record_via(uint16_t keycode, keyrecord_t *record) {
     return true;
 }
 
-// Keyboard level code can override this to handle custom messages from VIA.
-// See raw_hid_receive() implementation.
+//
+// via_custom_value_command() has the default handling of custom values for Core modules.
+// If a keyboard is using the default Core modules, it does not need to be overridden,
+// the VIA keyboard definition will have matching channel/IDs.
+//
+// If a keyboard has some extra custom values, then via_custom_value_command_kb() can be
+// overridden to handle the extra custom values, leaving via_custom_value_command() to
+// handle the custom values for Core modules.
+//
+// If a keyboard has custom values and code that are overlapping with Core modules,
+// then via_custom_value_command() can be overridden and call the same functions
+// as the default implementation, or do whatever else is required.
+//
 // DO NOT call raw_hid_send() in the override function.
-__attribute__((weak)) void raw_hid_receive_kb(uint8_t *data, uint8_t length) {
+//
+
+// This is the default handler for "extra" custom values, i.e. keyboard-specific custom values
+// that are not handled by via_custom_value_command().
+__attribute__((weak)) void via_custom_value_command_kb(uint8_t *data, uint8_t length) {
+    // data = [ command_id, channel_id, value_id, value_data ]
     uint8_t *command_id = &(data[0]);
-    *command_id         = id_unhandled;
+    // Return the unhandled state
+    *command_id = id_unhandled;
 }
 
-// VIA handles received HID messages first, and will route to
-// raw_hid_receive_kb() for command IDs that are not handled here.
-// This gives the keyboard code level the ability to handle the command
-// specifically.
-//
-// raw_hid_send() is called at the end, with the same buffer, which was
-// possibly modified with returned values.
-void raw_hid_receive(uint8_t *data, uint8_t length) {
+// This is the default handler for custom value commands.
+// It routes channel VIA_QMK_BACKLIGHT_CHANNEL to via_qmk_backlight_command() and
+// channel VIA_QMK_RGBLIGHT_CHANNEL to via_qmk_rgblight_command().
+__attribute__((weak)) void via_custom_value_command(uint8_t *data, uint8_t length) {
+    // data = [ command_id, channel_id, value_id, value_data ]
+    uint8_t *channel_id = &(data[1]);
+
+#if defined(VIA_QMK_BACKLIGHT_ENABLE)
+    if (*channel_id == id_qmk_backlight_channel) {
+        via_qmk_backlight_command(data, length);
+        return;
+    }
+#endif  // VIA_QMK_BACKLIGHT_ENABLE
+
+#if defined(VIA_QMK_RGBLIGHT_ENABLE)
+    if (*channel_id == id_qmk_rgblight_channel) {
+        via_qmk_rgblight_command(data, length);
+        return;
+    }
+#endif  // VIA_QMK_RGBLIGHT_ENABLE
+
+#if defined(VIA_QMK_RGB_MATRIX_ENABLE)
+    if (*channel_id == id_qmk_rgb_matrix_channel) {
+        via_qmk_rgb_matrix_command(data, length);
+        return;
+    }
+#endif  // VIA_QMK_RGBLIGHT_ENABL
+
+#if defined(VIA_QMK_AUDIO_ENABLE)
+    if (*channel_id == id_qmk_audio_channel) {
+        via_qmk_audio_command(data, length);
+        return;
+    }
+#endif  // VIA_QMK_AUDIO_ENABLE
+
+    *channel_id = *channel_id;  // force use of variable
+
+    // If we haven't returned before here, then let the keyboard level code
+    // handle this, if it is overridden, otherwise by default, this will
+    // return the unhandled state.
+    via_custom_value_command_kb(data, length);
+}
+
+// Keyboard level code can override this, but shouldn't need to.
+// Controlling custom features should be done by overriding
+// via_custom_value_command_kb() instead.
+__attribute__((weak)) bool via_command_kb(uint8_t *data, uint8_t length) {
+    return false;
+}
+
+void via_raw_hid_receive(uint8_t *data, uint8_t length) {
     uint8_t *command_id   = &(data[0]);
     uint8_t *command_data = &(data[1]);
+
+    // If via_command_kb() returns true, the command was fully
+    // handled, including calling raw_hid_send()
+    if ( via_command_kb(data, length) ) {
+        return;
+    }
+
     switch (*command_id) {
         case id_get_protocol_version: {
             command_data[0] = VIA_PROTOCOL_VERSION >> 8;
@@ -238,7 +299,10 @@ void raw_hid_receive(uint8_t *data, uint8_t length) {
                     break;
                 }
                 case id_switch_matrix_state: {
-#if ((MATRIX_COLS / 8 + 1) * MATRIX_ROWS <= 28)
+// Round up to the nearest number of bytes required to hold row state.
+// Multiply by number of rows to get the required size in bytes.
+// Guard against this being too big for the HID message.
+#if ( ((MATRIX_COLS+7)/8) * MATRIX_ROWS <= 28 )
                     uint8_t i = 1;
                     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
                         matrix_row_t value = matrix_get_row(row);
@@ -256,8 +320,18 @@ void raw_hid_receive(uint8_t *data, uint8_t length) {
 #endif
                     break;
                 }
+                case id_firmware_version: {
+                    uint32_t value  = VIA_FIRMWARE_VERSION;
+                    command_data[1] = (value >> 24) & 0xFF;
+                    command_data[2] = (value >> 16) & 0xFF;
+                    command_data[3] = (value >> 8) & 0xFF;
+                    command_data[4] = value & 0xFF;
+                    break;
+                }
                 default: {
-                    raw_hid_receive_kb(data, length);
+                    // The value ID is not known
+                    // Return the unhandled state
+                    *command_id = id_unhandled;
                     break;
                 }
             }
@@ -270,8 +344,15 @@ void raw_hid_receive(uint8_t *data, uint8_t length) {
                     via_set_layout_options(value);
                     break;
                 }
+                case id_device_indication: {
+                    uint8_t value = command_data[1];
+                    via_set_device_indication(value);
+                    break;
+                }
                 default: {
-                    raw_hid_receive_kb(data, length);
+                    // The value ID is not known
+                    // Return the unhandled state
+                    *command_id = id_unhandled;
                     break;
                 }
             }
@@ -291,61 +372,10 @@ void raw_hid_receive(uint8_t *data, uint8_t length) {
             dynamic_keymap_reset();
             break;
         }
-        case id_lighting_set_value: {
-#if defined(VIA_QMK_BACKLIGHT_ENABLE)
-            via_qmk_backlight_set_value(command_data);
-#endif
-#if defined(VIA_QMK_RGBLIGHT_ENABLE)
-            via_qmk_rgblight_set_value(command_data);
-#endif
-#if defined(VIA_QMK_RGB_MATRIX_ENABLE)
-            via_qmk_rgb_matrix_set_value(command_data);
-#endif
-#if defined(VIA_CUSTOM_LIGHTING_ENABLE)
-            raw_hid_receive_kb(data, length);
-#endif
-#if !defined(VIA_QMK_BACKLIGHT_ENABLE) && !defined(VIA_QMK_RGBLIGHT_ENABLE) && !defined(VIA_CUSTOM_LIGHTING_ENABLE) && !defined(VIA_QMK_RGB_MATRIX_ENABLE)
-            // Return the unhandled state
-            *command_id = id_unhandled;
-#endif
-            break;
-        }
-        case id_lighting_get_value: {
-#if defined(VIA_QMK_BACKLIGHT_ENABLE)
-            via_qmk_backlight_get_value(command_data);
-#endif
-#if defined(VIA_QMK_RGBLIGHT_ENABLE)
-            via_qmk_rgblight_get_value(command_data);
-#endif
-#if defined(VIA_QMK_RGB_MATRIX_ENABLE)
-            via_qmk_rgb_matrix_get_value(command_data);
-#endif
-#if defined(VIA_CUSTOM_LIGHTING_ENABLE)
-            raw_hid_receive_kb(data, length);
-#endif
-#if !defined(VIA_QMK_BACKLIGHT_ENABLE) && !defined(VIA_QMK_RGBLIGHT_ENABLE) && !defined(VIA_CUSTOM_LIGHTING_ENABLE) && !defined(VIA_QMK_RGB_MATRIX_ENABLE)
-            // Return the unhandled state
-            *command_id = id_unhandled;
-#endif
-            break;
-        }
-        case id_lighting_save: {
-#if defined(VIA_QMK_BACKLIGHT_ENABLE)
-            eeconfig_update_backlight_current();
-#endif
-#if defined(VIA_QMK_RGBLIGHT_ENABLE)
-            eeconfig_update_rgblight_current();
-#endif
-#if defined(VIA_QMK_RGB_MATRIX_ENABLE)
-            eeconfig_update_rgb_matrix();
-#endif
-#if defined(VIA_CUSTOM_LIGHTING_ENABLE)
-            raw_hid_receive_kb(data, length);
-#endif
-#if !defined(VIA_QMK_BACKLIGHT_ENABLE) && !defined(VIA_QMK_RGBLIGHT_ENABLE) && !defined(VIA_CUSTOM_LIGHTING_ENABLE) && !defined(VIA_QMK_RGB_MATRIX_ENABLE)
-            // Return the unhandled state
-            *command_id = id_unhandled;
-#endif
+        case id_custom_set_value:
+        case id_custom_get_value:
+        case id_custom_save: {
+            via_custom_value_command(data, length);
             break;
         }
 #ifdef VIA_EEPROM_ALLOW_RESET
@@ -424,11 +454,37 @@ void raw_hid_receive(uint8_t *data, uint8_t length) {
 
 #if defined(VIA_QMK_BACKLIGHT_ENABLE)
 
+void via_qmk_backlight_command(uint8_t *data, uint8_t length) {
+    // data = [ command_id, channel_id, value_id, value_data ]
+    uint8_t *command_id        = &(data[0]);
+    uint8_t *value_id_and_data = &(data[2]);
+
+    switch (*command_id) {
+        case id_custom_set_value: {
+            via_qmk_backlight_set_value(value_id_and_data);
+            break;
+        }
+        case id_custom_get_value: {
+            via_qmk_backlight_get_value(value_id_and_data);
+            break;
+        }
+        case id_custom_save: {
+            via_qmk_backlight_save();
+            break;
+        }
+        default: {
+            *command_id = id_unhandled;
+            break;
+        }
+    }
+}
+
 #    if BACKLIGHT_LEVELS == 0
 #        error BACKLIGHT_LEVELS == 0
 #    endif
 
 void via_qmk_backlight_get_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
     uint8_t *value_id   = &(data[0]);
     uint8_t *value_data = &(data[1]);
     switch (*value_id) {
@@ -449,6 +505,7 @@ void via_qmk_backlight_get_value(uint8_t *data) {
 }
 
 void via_qmk_backlight_set_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
     uint8_t *value_id   = &(data[0]);
     uint8_t *value_data = &(data[1]);
     switch (*value_id) {
@@ -470,14 +527,42 @@ void via_qmk_backlight_set_value(uint8_t *data) {
     }
 }
 
-#endif // #if defined(VIA_QMK_BACKLIGHT_ENABLE)
+void via_qmk_backlight_save(void) { eeconfig_update_backlight_current(); }
+
+#endif  // #if defined(VIA_QMK_BACKLIGHT_ENABLE)
 
 #if defined(VIA_QMK_RGBLIGHT_ENABLE)
 #    ifndef RGBLIGHT_LIMIT_VAL
 #        define RGBLIGHT_LIMIT_VAL 255
 #    endif
 
+void via_qmk_rgblight_command(uint8_t *data, uint8_t length) {
+    // data = [ command_id, channel_id, value_id, value_data ]
+    uint8_t *command_id        = &(data[0]);
+    uint8_t *value_id_and_data = &(data[2]);
+
+    switch (*command_id) {
+        case id_custom_set_value: {
+            via_qmk_rgblight_set_value(value_id_and_data);
+            break;
+        }
+        case id_custom_get_value: {
+            via_qmk_rgblight_get_value(value_id_and_data);
+            break;
+        }
+        case id_custom_save: {
+            via_qmk_rgblight_save();
+            break;
+        }
+        default: {
+            *command_id = id_unhandled;
+            break;
+        }
+    }
+}
+
 void via_qmk_rgblight_get_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
     uint8_t *value_id   = &(data[0]);
     uint8_t *value_data = &(data[1]);
     switch (*value_id) {
@@ -486,7 +571,7 @@ void via_qmk_rgblight_get_value(uint8_t *data) {
             break;
         }
         case id_qmk_rgblight_effect: {
-            value_data[0] = rgblight_get_mode();
+            value_data[0] = rgblight_is_enabled() ? rgblight_get_mode() : 0;
             break;
         }
         case id_qmk_rgblight_effect_speed: {
@@ -502,6 +587,7 @@ void via_qmk_rgblight_get_value(uint8_t *data) {
 }
 
 void via_qmk_rgblight_set_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
     uint8_t *value_id   = &(data[0]);
     uint8_t *value_data = &(data[1]);
     switch (*value_id) {
@@ -510,11 +596,11 @@ void via_qmk_rgblight_set_value(uint8_t *data) {
             break;
         }
         case id_qmk_rgblight_effect: {
-            rgblight_mode_noeeprom(value_data[0]);
             if (value_data[0] == 0) {
                 rgblight_disable_noeeprom();
             } else {
                 rgblight_enable_noeeprom();
+                rgblight_mode_noeeprom(value_data[0]);
             }
             break;
         }
@@ -529,7 +615,9 @@ void via_qmk_rgblight_set_value(uint8_t *data) {
     }
 }
 
-#endif // #if defined(VIA_QMK_RGBLIGHT_ENABLE)
+void via_qmk_rgblight_save(void) { eeconfig_update_rgblight_current(); }
+
+#endif  // #if defined(VIA_QMK_RGBLIGHT_ENABLE)
 
 #if defined(VIA_QMK_RGB_MATRIX_ENABLE)
 
@@ -538,83 +626,162 @@ void via_qmk_rgblight_set_value(uint8_t *data) {
 #        define RGB_MATRIX_MAXIMUM_BRIGHTNESS UINT8_MAX
 #    endif
 
-// VIA supports only 4 discrete values for effect speed; map these to some
-// useful speed values for RGB Matrix.
-enum speed_values {
-    RGBLIGHT_SPEED_0 = UINT8_MAX / 16, // not 0 to avoid really slow effects
-    RGBLIGHT_SPEED_1 = UINT8_MAX / 4,
-    RGBLIGHT_SPEED_2 = UINT8_MAX / 2,     // matches the default value
-    RGBLIGHT_SPEED_3 = UINT8_MAX / 4 * 3, // UINT8_MAX is really fast
-};
-
-static uint8_t speed_from_rgblight(uint8_t rgblight_speed) {
-    switch (rgblight_speed) {
-        case 0:
-            return RGBLIGHT_SPEED_0;
-        case 1:
-            return RGBLIGHT_SPEED_1;
-        case 2:
-        default:
-            return RGBLIGHT_SPEED_2;
-        case 3:
-            return RGBLIGHT_SPEED_3;
-    }
-}
+void via_qmk_rgb_matrix_command(uint8_t *data, uint8_t length) {
+    // data = [ command_id, channel_id, value_id, value_data ]
+    uint8_t *command_id        = &(data[0]);
+    uint8_t *value_id_and_data = &(data[2]);
 
-static uint8_t speed_to_rgblight(uint8_t rgb_matrix_speed) {
-    if (rgb_matrix_speed < ((RGBLIGHT_SPEED_0 + RGBLIGHT_SPEED_1) / 2)) {
-        return 0;
-    } else if (rgb_matrix_speed < ((RGBLIGHT_SPEED_1 + RGBLIGHT_SPEED_2) / 2)) {
-        return 1;
-    } else if (rgb_matrix_speed < ((RGBLIGHT_SPEED_2 + RGBLIGHT_SPEED_3) / 2)) {
-        return 2;
-    } else {
-        return 3;
+    switch (*command_id) {
+        case id_custom_set_value: {
+            via_qmk_rgb_matrix_set_value(value_id_and_data);
+            break;
+        }
+        case id_custom_get_value: {
+            via_qmk_rgb_matrix_get_value(value_id_and_data);
+            break;
+        }
+        case id_custom_save: {
+            via_qmk_rgb_matrix_save();
+            break;
+        }
+        default: {
+            *command_id = id_unhandled;
+            break;
+        }
     }
 }
 
 void via_qmk_rgb_matrix_get_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
     uint8_t *value_id   = &(data[0]);
     uint8_t *value_data = &(data[1]);
+
     switch (*value_id) {
-        case id_qmk_rgblight_brightness:
+        case id_qmk_rgblight_brightness: {
             value_data[0] = ((uint16_t)rgb_matrix_get_val() * UINT8_MAX) / RGB_MATRIX_MAXIMUM_BRIGHTNESS;
             break;
-        case id_qmk_rgblight_effect:
-            value_data[0] = rgb_matrix_get_mode();
+        }
+        case id_qmk_rgb_matrix_effect: {
+            value_data[0] = rgb_matrix_is_enabled() ? rgb_matrix_get_mode() : 0;
             break;
-        case id_qmk_rgblight_effect_speed:
-            value_data[0] = speed_to_rgblight(rgb_matrix_get_speed());
+        }
+        case id_qmk_rgb_matrix_effect_speed: {
+            value_data[0] = rgb_matrix_get_speed();
             break;
-        case id_qmk_rgblight_color:
+        }
+        case id_qmk_rgb_matrix_color: {
             value_data[0] = rgb_matrix_get_hue();
             value_data[1] = rgb_matrix_get_sat();
             break;
+        }
     }
 }
 
 void via_qmk_rgb_matrix_set_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
     uint8_t *value_id   = &(data[0]);
     uint8_t *value_data = &(data[1]);
     switch (*value_id) {
-        case id_qmk_rgblight_brightness:
+
+        case id_qmk_rgblight_brightness: {
+#ifdef RGB_MATRIX_TURN_OFF_VAL
+            if (!rgb_matrix_is_enabled() && value_data[0] >= RGB_MATRIX_TURN_OFF_VAL)  {
+                rgb_matrix_toggle_noeeprom();
+            }
+#endif
             rgb_matrix_sethsv_noeeprom(rgb_matrix_get_hue(), rgb_matrix_get_sat(), scale8(value_data[0], RGB_MATRIX_MAXIMUM_BRIGHTNESS));
+#ifdef RGB_MATRIX_TURN_OFF_VAL
+            if (rgb_matrix_is_enabled() && value_data[0] < RGB_MATRIX_TURN_OFF_VAL)  {
+                rgb_matrix_toggle_noeeprom();
+            }
+#endif
             break;
-        case id_qmk_rgblight_effect:
-            rgb_matrix_mode_noeeprom(value_data[0]);
+        }
+        case id_qmk_rgb_matrix_effect: {
             if (value_data[0] == 0) {
                 rgb_matrix_disable_noeeprom();
             } else {
                 rgb_matrix_enable_noeeprom();
+                rgb_matrix_mode_noeeprom(value_data[0]);
             }
             break;
-        case id_qmk_rgblight_effect_speed:
-            rgb_matrix_set_speed_noeeprom(speed_from_rgblight(value_data[0]));
+        }
+        case id_qmk_rgb_matrix_effect_speed: {
+            rgblight_set_speed_noeeprom(value_data[0]);
+            break;
+        }
+        case id_qmk_rgb_matrix_color: {
+            rgblight_sethsv_noeeprom(value_data[0], value_data[1], rgb_matrix_get_val());
+            break;
+        }
+    }
+}
+
+void via_qmk_rgb_matrix_save(void) { eeconfig_update_rgb_matrix(); }
+
+#endif  // #if defined(VIA_QMK_RGB_MATRIX_ENABLE)
+
+#if defined(VIA_QMK_AUDIO_ENABLE)
+
+extern audio_config_t audio_config;
+
+void via_qmk_audio_command(uint8_t *data, uint8_t length) {
+    // data = [ command_id, channel_id, value_id, value_data ]
+    uint8_t *command_id        = &(data[0]);
+    uint8_t *value_id_and_data = &(data[2]);
+
+    switch (*command_id) {
+        case id_custom_set_value: {
+            via_qmk_audio_set_value(value_id_and_data);
+            break;
+        }
+        case id_custom_get_value: {
+            via_qmk_audio_get_value(value_id_and_data);
+            break;
+        }
+        case id_custom_save: {
+            via_qmk_audio_save();
+            break;
+        }
+        default: {
+            *command_id = id_unhandled;
+            break;
+        }
+    }
+}
+
+void via_qmk_audio_get_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
+    uint8_t *value_id   = &(data[0]);
+    uint8_t *value_data = &(data[1]);
+    switch (*value_id) {
+        case id_qmk_audio_enable: {
+            value_data[0] = audio_config.enable ? 1 : 0;
+            break;
+        }
+        case id_qmk_audio_clicky_enable: {
+            value_data[0] = audio_config.clicky_enable ? 1 : 0;
+            break;
+        }
+    }
+}
+
+void via_qmk_audio_set_value(uint8_t *data) {
+    // data = [ value_id, value_data ]
+    uint8_t *value_id   = &(data[0]);
+    uint8_t *value_data = &(data[1]);
+    switch (*value_id) {
+        case id_qmk_audio_enable: {
+            audio_config.enable = value_data[0] ? 1 : 0;
             break;
-        case id_qmk_rgblight_color:
-            rgb_matrix_sethsv_noeeprom(value_data[0], value_data[1], rgb_matrix_get_val());
+        }
+        case id_qmk_audio_clicky_enable: {
+            audio_config.clicky_enable = value_data[0] ? 1 : 0;
             break;
+        }
     }
 }
 
-#endif // #if defined(VIA_QMK_RGB_MATRIX_ENABLE)
+void via_qmk_audio_save(void) { eeconfig_update_audio(audio_config.raw); }
+
+#endif  // #if defined(VIA_QMK_AUDIO_ENABLE)
diff --git a/quantum/via.h b/quantum/via.h
index 558ae95de4..600302e82f 100644
--- a/quantum/via.h
+++ b/quantum/via.h
@@ -58,7 +58,35 @@
 
 // This is changed only when the command IDs change,
 // so VIA Configurator can detect compatible firmware.
-#define VIA_PROTOCOL_VERSION 0x000A
+#define VIA_PROTOCOL_VERSION 0x000B
+
+// This is a version number for the firmware for the keyboard.
+// It can be used to ensure the VIA keyboard definition and the firmware
+// have the same version, especially if there are changes to custom values.
+// Define this in config.h to override and bump this number.
+// This is *not* required if the keyboard is only using basic functionality
+// and not using custom values for lighting, rotary encoders, etc.
+#ifndef VIA_FIRMWARE_VERSION
+#    define VIA_FIRMWARE_VERSION 0x00000000
+#endif
+
+// Enable the VIA command handlers for QMK Core features if those features
+// are enabled.
+#if defined(BACKLIGHT_ENABLE)
+#    define VIA_QMK_BACKLIGHT_ENABLE
+#endif
+
+#if defined(RGBLIGHT_ENABLE)
+#    define VIA_QMK_RGBLIGHT_ENABLE
+#endif
+
+#if defined(RGB_MATRIX_ENABLE)
+#    define VIA_QMK_RGB_MATRIX_ENABLE
+#endif
+
+#if defined(AUDIO_ENABLE)
+#    define VIA_QMK_AUDIO_ENABLE
+#endif
 
 enum via_command_id {
     id_get_protocol_version                 = 0x01, // always 0x01
@@ -67,9 +95,9 @@ enum via_command_id {
     id_dynamic_keymap_get_keycode           = 0x04,
     id_dynamic_keymap_set_keycode           = 0x05,
     id_dynamic_keymap_reset                 = 0x06,
-    id_lighting_set_value                   = 0x07,
-    id_lighting_get_value                   = 0x08,
-    id_lighting_save                        = 0x09,
+    id_custom_set_value                     = 0x07,
+    id_custom_get_value                     = 0x08,
+    id_custom_save                          = 0x09,
     id_eeprom_reset                         = 0x0A,
     id_bootloader_jump                      = 0x0B,
     id_dynamic_keymap_macro_get_count       = 0x0C,
@@ -86,21 +114,43 @@ enum via_command_id {
 };
 
 enum via_keyboard_value_id {
-    id_uptime              = 0x01, //
+    id_uptime              = 0x01,
     id_layout_options      = 0x02,
-    id_switch_matrix_state = 0x03
+    id_switch_matrix_state = 0x03,
+    id_firmware_version    = 0x04,
+    id_device_indication   = 0x05
+};
+
+enum via_channel_id {
+    id_custom_channel         = 0,
+    id_qmk_backlight_channel  = 1,
+    id_qmk_rgblight_channel   = 2,
+    id_qmk_rgb_matrix_channel = 3,
+    id_qmk_audio_channel      = 4
+};
+
+enum via_qmk_backlight_value {
+    id_qmk_backlight_brightness = 1,
+    id_qmk_backlight_effect     = 2
+};
+
+enum via_qmk_rgblight_value {
+    id_qmk_rgblight_brightness   = 1,
+    id_qmk_rgblight_effect       = 2,
+    id_qmk_rgblight_effect_speed = 3,
+    id_qmk_rgblight_color        = 4
 };
 
-enum via_lighting_value {
-    // QMK BACKLIGHT
-    id_qmk_backlight_brightness = 0x09,
-    id_qmk_backlight_effect     = 0x0A,
+enum via_qmk_rgb_matrix_value {
+    id_qmk_rgb_matrix_brightness   = 1,
+    id_qmk_rgb_matrix_effect       = 2,
+    id_qmk_rgb_matrix_effect_speed = 3,
+    id_qmk_rgb_matrix_color        = 4
+};
 
-    // QMK RGBLIGHT
-    id_qmk_rgblight_brightness   = 0x80,
-    id_qmk_rgblight_effect       = 0x81,
-    id_qmk_rgblight_effect_speed = 0x82,
-    id_qmk_rgblight_color        = 0x83,
+enum via_qmk_audio_value {
+    id_qmk_audio_enable        = 1,
+    id_qmk_audio_clicky_enable = 2
 };
 
 // Can't use SAFE_RANGE here, it might change if someone adds
@@ -165,5 +215,40 @@ uint32_t via_get_layout_options(void);
 void     via_set_layout_options(uint32_t value);
 void     via_set_layout_options_kb(uint32_t value);
 
+// Used by VIA to tell a device to flash LEDs (or do something else) when that
+// device becomes the active device being configured, on startup or switching
+// between devices.
+void via_set_device_indication(uint8_t value);
+
 // Called by QMK core to process VIA-specific keycodes.
 bool process_record_via(uint16_t keycode, keyrecord_t *record);
+void via_raw_hid_receive(uint8_t *data, uint8_t length);
+
+// These are made external so that keyboard level custom value handlers can use them.
+#if defined(VIA_QMK_BACKLIGHT_ENABLE)
+void via_qmk_backlight_command(uint8_t *data, uint8_t length);
+void via_qmk_backlight_set_value(uint8_t *data);
+void via_qmk_backlight_get_value(uint8_t *data);
+void via_qmk_backlight_save(void);
+#endif
+
+#if defined(VIA_QMK_RGBLIGHT_ENABLE)
+void via_qmk_rgblight_command(uint8_t *data, uint8_t length);
+void via_qmk_rgblight_set_value(uint8_t *data);
+void via_qmk_rgblight_get_value(uint8_t *data);
+void via_qmk_rgblight_save(void);
+#endif
+
+#if defined(VIA_QMK_RGB_MATRIX_ENABLE)
+void via_qmk_rgb_matrix_command(uint8_t *data, uint8_t length);
+void via_qmk_rgb_matrix_set_value(uint8_t *data);
+void via_qmk_rgb_matrix_get_value(uint8_t *data);
+void via_qmk_rgb_matrix_save(void);
+#endif
+
+#if defined(VIA_QMK_AUDIO_ENABLE)
+void via_qmk_audio_command(uint8_t *data, uint8_t length);
+void via_qmk_audio_set_value(uint8_t *data);
+void via_qmk_audio_get_value(uint8_t *data);
+void via_qmk_audio_save(void);
+#endif
