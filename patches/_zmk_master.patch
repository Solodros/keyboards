diff --git a/app/CMakeLists.txt b/app/CMakeLists.txt
index 4c1c63c..efa3490 100644
--- a/app/CMakeLists.txt
+++ b/app/CMakeLists.txt
@@ -87,6 +87,7 @@ target_sources_ifdef(CONFIG_USB_DEVICE_STACK app PRIVATE src/usb.c)
 target_sources_ifdef(CONFIG_ZMK_USB app PRIVATE src/usb_hid.c)
 target_sources_ifdef(CONFIG_ZMK_RGB_UNDERGLOW app PRIVATE src/rgb_underglow.c)
 target_sources_ifdef(CONFIG_ZMK_BACKLIGHT app PRIVATE src/backlight.c)
+target_sources(app PRIVATE src/workqueue.c)
 target_sources(app PRIVATE src/main.c)
 
 add_subdirectory(src/display/)
diff --git a/app/Kconfig b/app/Kconfig
index 12e24f6..65b7ec0 100644
--- a/app/Kconfig
+++ b/app/Kconfig
@@ -495,10 +495,18 @@ config ZMK_SETTINGS_SAVE_DEBOUNCE
 endif
 
 config ZMK_BATTERY_REPORT_INTERVAL
-    depends on ZMK_BLE
+    depends on ZMK_BATTERY_REPORTING
     int "Battery level report interval in seconds"
     default 60
 
+config ZMK_LOW_PRIORITY_THREAD_STACK_SIZE
+    int "Low priority thread stack size"
+    default 768
+
+config ZMK_LOW_PRIORITY_THREAD_PRIORITY
+    int "Low priority thread priority"
+    default 10
+
 #Advanced
 endmenu
 
diff --git a/app/drivers/kscan/kscan_mock.c b/app/drivers/kscan/kscan_mock.c
index e1a41bb..57862b0 100644
--- a/app/drivers/kscan/kscan_mock.c
+++ b/app/drivers/kscan/kscan_mock.c
@@ -9,7 +9,6 @@
 #include <stdlib.h>
 #include <zephyr/device.h>
 #include <zephyr/drivers/kscan.h>
-#include <zephyr/kernel.h>
 #include <zephyr/logging/log.h>
 
 LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
diff --git a/app/drivers/sensor/battery/Kconfig b/app/drivers/sensor/battery/Kconfig
index a9d7189..703adeb 100644
--- a/app/drivers/sensor/battery/Kconfig
+++ b/app/drivers/sensor/battery/Kconfig
@@ -14,6 +14,7 @@ config ZMK_BATTERY_NRF_VDDH
     default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BATTERY_NRF_VDDH))
     select ADC
     select ZMK_BATTERY
+    depends on SENSOR
     help
         Enable ZMK nRF VDDH voltage driver for battery monitoring.
 
@@ -22,5 +23,6 @@ config ZMK_BATTERY_VOLTAGE_DIVIDER
     default $(dt_compat_enabled,$(DT_COMPAT_ZMK_BATTERY_VOLTAGE_DIVIDER))
     select ADC
     select ZMK_BATTERY
+    depends on SENSOR
     help
         Enable ZMK battery voltage divider driver for battery monitoring.
diff --git a/app/drivers/sensor/battery/battery_nrf_vddh.c b/app/drivers/sensor/battery/battery_nrf_vddh.c
index 3f23081..32c7c61 100644
--- a/app/drivers/sensor/battery/battery_nrf_vddh.c
+++ b/app/drivers/sensor/battery/battery_nrf_vddh.c
@@ -93,7 +93,7 @@ static int vddh_init(const struct device *dev) {
 
 #ifdef CONFIG_ADC_NRFX_SAADC
     drv_data->acc = (struct adc_channel_cfg){
-        .gain = ADC_GAIN_1_5,
+        .gain = ADC_GAIN_1_2,
         .reference = ADC_REF_INTERNAL,
         .acquisition_time = ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 40),
         .input_positive = SAADC_CH_PSELN_PSELN_VDDHDIV5,
diff --git a/app/drivers/sensor/battery/battery_voltage_divider.c b/app/drivers/sensor/battery/battery_voltage_divider.c
index 655af3d..62a02e9 100644
--- a/app/drivers/sensor/battery/battery_voltage_divider.c
+++ b/app/drivers/sensor/battery/battery_voltage_divider.c
@@ -140,7 +140,7 @@ static int bvd_init(const struct device *dev) {
 
 #ifdef CONFIG_ADC_NRFX_SAADC
     drv_data->acc = (struct adc_channel_cfg){
-        .gain = ADC_GAIN_1_5,
+        .gain = ADC_GAIN_1_6,
         .reference = ADC_REF_INTERNAL,
         .acquisition_time = ADC_ACQ_TIME(ADC_ACQ_TIME_MICROSECONDS, 40),
         .input_positive = SAADC_CH_PSELP_PSELP_AnalogInput0 + drv_cfg->io_channel.channel,
diff --git a/app/include/zmk/keymap.h b/app/include/zmk/keymap.h
index a47cd50..9ce140b 100644
--- a/app/include/zmk/keymap.h
+++ b/app/include/zmk/keymap.h
@@ -8,6 +8,10 @@
 
 #include <zmk/events/position_state_changed.h>
 
+#define ZMK_LAYER_CHILD_LEN_PLUS_ONE(node) 1 +
+#define ZMK_KEYMAP_LAYERS_LEN                                                                      \
+    (DT_FOREACH_CHILD(DT_INST(0, zmk_keymap), ZMK_LAYER_CHILD_LEN_PLUS_ONE) 0)
+
 typedef uint32_t zmk_keymap_layers_state_t;
 
 uint8_t zmk_keymap_layer_default();
diff --git a/app/include/zmk/sensors.h b/app/include/zmk/sensors.h
index 8ac1c28..1919d4c 100644
--- a/app/include/zmk/sensors.h
+++ b/app/include/zmk/sensors.h
@@ -24,7 +24,9 @@ struct zmk_sensor_config {
     uint16_t triggers_per_rotation;
 };
 
+// This struct is also used for data transfer for splits, so any changes to the size, layout, etc
+// is a breaking change for the split GATT service protocol.
 struct zmk_sensor_channel_data {
-    enum sensor_channel channel;
     struct sensor_value value;
-};
+    enum sensor_channel channel;
+} __packed;
diff --git a/app/include/zmk/split/bluetooth/service.h b/app/include/zmk/split/bluetooth/service.h
index f0c1d79..112cd55 100644
--- a/app/include/zmk/split/bluetooth/service.h
+++ b/app/include/zmk/split/bluetooth/service.h
@@ -6,8 +6,18 @@
 
 #pragma once
 
+#include <zmk/events/sensor_event.h>
+#include <zmk/sensors.h>
+
 #define ZMK_SPLIT_RUN_BEHAVIOR_DEV_LEN 9
 
+struct sensor_event {
+    uint8_t sensor_index;
+
+    uint8_t channel_data_size;
+    struct zmk_sensor_channel_data channel_data[ZMK_SENSOR_EVENT_MAX_CHANNELS];
+} __packed;
+
 struct zmk_split_run_behavior_data {
     uint8_t position;
     uint8_t state;
@@ -21,4 +31,7 @@ struct zmk_split_run_behavior_payload {
 } __packed;
 
 int zmk_split_bt_position_pressed(uint8_t position);
-int zmk_split_bt_position_released(uint8_t position);
\ No newline at end of file
+int zmk_split_bt_position_released(uint8_t position);
+int zmk_split_bt_sensor_triggered(uint8_t sensor_index,
+                                  const struct zmk_sensor_channel_data channel_data[],
+                                  size_t channel_data_size);
diff --git a/app/include/zmk/split/bluetooth/uuid.h b/app/include/zmk/split/bluetooth/uuid.h
index cbdb177..c38131d 100644
--- a/app/include/zmk/split/bluetooth/uuid.h
+++ b/app/include/zmk/split/bluetooth/uuid.h
@@ -16,3 +16,4 @@
 #define ZMK_SPLIT_BT_SERVICE_UUID ZMK_BT_SPLIT_UUID(0x00000000)
 #define ZMK_SPLIT_BT_CHAR_POSITION_STATE_UUID ZMK_BT_SPLIT_UUID(0x00000001)
 #define ZMK_SPLIT_BT_CHAR_RUN_BEHAVIOR_UUID ZMK_BT_SPLIT_UUID(0x00000002)
+#define ZMK_SPLIT_BT_CHAR_SENSOR_STATE_UUID ZMK_BT_SPLIT_UUID(0x00000003)
diff --git a/app/include/zmk/workqueue.h b/app/include/zmk/workqueue.h
new file mode 100644
index 0000000..41e9458
--- /dev/null
+++ b/app/include/zmk/workqueue.h
@@ -0,0 +1 @@
+struct k_work_q *zmk_workqueue_lowprio_work_q();
diff --git a/app/src/battery.c b/app/src/battery.c
index 0e63605..5c369f9 100644
--- a/app/src/battery.c
+++ b/app/src/battery.c
@@ -18,6 +18,7 @@ LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
 #include <zmk/event_manager.h>
 #include <zmk/battery.h>
 #include <zmk/events/battery_state_changed.h>
+#include <zmk/workqueue.h>
 
 static uint8_t last_state_of_charge = 0;
 
@@ -77,7 +78,9 @@ static void zmk_battery_work(struct k_work *work) {
 
 K_WORK_DEFINE(battery_work, zmk_battery_work);
 
-static void zmk_battery_timer(struct k_timer *timer) { k_work_submit(&battery_work); }
+static void zmk_battery_timer(struct k_timer *timer) {
+    k_work_submit_to_queue(zmk_workqueue_lowprio_work_q(), &battery_work);
+}
 
 K_TIMER_DEFINE(battery_timer, zmk_battery_timer, NULL);
 
@@ -97,14 +100,7 @@ static int zmk_battery_init(void) {
         return -ENODEV;
     }
 
-    int rc = zmk_battery_update(battery);
-
-    if (rc != 0) {
-        LOG_DBG("Failed to update battery value: %d.", rc);
-        return rc;
-    }
-
-    k_timer_start(&battery_timer, K_MINUTES(1), K_SECONDS(CONFIG_ZMK_BATTERY_REPORT_INTERVAL));
+    k_timer_start(&battery_timer, K_NO_WAIT, K_SECONDS(CONFIG_ZMK_BATTERY_REPORT_INTERVAL));
 
     return 0;
 }
diff --git a/app/src/behaviors/behavior_sensor_rotate_common.c b/app/src/behaviors/behavior_sensor_rotate_common.c
index 586cac3..98b4aec 100644
--- a/app/src/behaviors/behavior_sensor_rotate_common.c
+++ b/app/src/behaviors/behavior_sensor_rotate_common.c
@@ -28,7 +28,7 @@ int zmk_behavior_sensor_rotate_common_accept_data(
     if (value.val1 == 0) {
         triggers = value.val2;
     } else {
-        struct sensor_value remainder = data->remainder[sensor_index];
+        struct sensor_value remainder = data->remainder[sensor_index][event.layer];
 
         remainder.val1 += value.val1;
         remainder.val2 += value.val2;
@@ -42,15 +42,16 @@ int zmk_behavior_sensor_rotate_common_accept_data(
         triggers = remainder.val1 / trigger_degrees;
         remainder.val1 %= trigger_degrees;
 
-        data->remainder[sensor_index] = remainder;
+        data->remainder[sensor_index][event.layer] = remainder;
     }
 
     LOG_DBG(
         "val1: %d, val2: %d, remainder: %d/%d triggers: %d inc keycode 0x%02X dec keycode 0x%02X",
-        value.val1, value.val2, data->remainder[sensor_index].val1,
-        data->remainder[sensor_index].val2, triggers, binding->param1, binding->param2);
+        value.val1, value.val2, data->remainder[sensor_index][event.layer].val1,
+        data->remainder[sensor_index][event.layer].val2, triggers, binding->param1,
+        binding->param2);
 
-    data->triggers[sensor_index] = triggers;
+    data->triggers[sensor_index][event.layer] = triggers;
     return 0;
 }
 
@@ -64,11 +65,11 @@ int zmk_behavior_sensor_rotate_common_process(struct zmk_behavior_binding *bindi
     const int sensor_index = ZMK_SENSOR_POSITION_FROM_VIRTUAL_KEY_POSITION(event.position);
 
     if (mode != BEHAVIOR_SENSOR_BINDING_PROCESS_MODE_TRIGGER) {
-        data->triggers[sensor_index] = 0;
+        data->triggers[sensor_index][event.layer] = 0;
         return ZMK_BEHAVIOR_TRANSPARENT;
     }
 
-    int triggers = data->triggers[sensor_index];
+    int triggers = data->triggers[sensor_index][event.layer];
 
     struct zmk_behavior_binding triggered_binding;
     if (triggers > 0) {
diff --git a/app/src/behaviors/behavior_sensor_rotate_common.h b/app/src/behaviors/behavior_sensor_rotate_common.h
index d354b67..c92ac3d 100644
--- a/app/src/behaviors/behavior_sensor_rotate_common.h
+++ b/app/src/behaviors/behavior_sensor_rotate_common.h
@@ -6,6 +6,7 @@
 
 #include <drivers/behavior.h>
 #include <zmk/behavior.h>
+#include <zmk/keymap.h>
 #include <zmk/sensors.h>
 
 struct behavior_sensor_rotate_config {
@@ -16,8 +17,8 @@ struct behavior_sensor_rotate_config {
 };
 
 struct behavior_sensor_rotate_data {
-    struct sensor_value remainder[ZMK_KEYMAP_SENSORS_LEN];
-    int triggers[ZMK_KEYMAP_SENSORS_LEN];
+    struct sensor_value remainder[ZMK_KEYMAP_SENSORS_LEN][ZMK_KEYMAP_LAYERS_LEN];
+    int triggers[ZMK_KEYMAP_SENSORS_LEN][ZMK_KEYMAP_LAYERS_LEN];
 };
 
 int zmk_behavior_sensor_rotate_common_accept_data(
diff --git a/app/src/ble.c b/app/src/ble.c
index 4d0bfdf..cec7d2b 100644
--- a/app/src/ble.c
+++ b/app/src/ble.c
@@ -281,14 +281,19 @@ int zmk_ble_put_peripheral_addr(const bt_addr_le_t *addr) {
     for (int i = 0; i < ZMK_SPLIT_BLE_PERIPHERAL_COUNT; i++) {
         // If the address is recognized and already stored in settings, return
         // index and no additional action is necessary.
-        if (!bt_addr_le_cmp(&peripheral_addrs[i], addr)) {
+        if (bt_addr_le_cmp(&peripheral_addrs[i], addr) == 0) {
+            LOG_DBG("Found existing peripheral address in slot %d", i);
             return i;
+        } else {
+            char addr_str[BT_ADDR_LE_STR_LEN];
+            bt_addr_le_to_str(&peripheral_addrs[i], addr_str, sizeof(addr_str));
+            LOG_DBG("peripheral slot %d occupied by %s", i, addr_str);
         }
 
         // If the peripheral address slot is open, store new peripheral in the
         // slot and return index. This compares against BT_ADDR_LE_ANY as that
         // is the zero value.
-        if (!bt_addr_le_cmp(&peripheral_addrs[i], BT_ADDR_LE_ANY)) {
+        if (bt_addr_le_cmp(&peripheral_addrs[i], BT_ADDR_LE_ANY) == 0) {
             char addr_str[BT_ADDR_LE_STR_LEN];
             bt_addr_le_to_str(addr, addr_str, sizeof(addr_str));
             LOG_DBG("Storing peripheral %s in slot %d", addr_str, i);
@@ -606,7 +611,7 @@ static int zmk_ble_init(void) {
 
     bt_unpair(BT_ID_DEFAULT, NULL);
 
-    for (int i = 0; i < ZMK_BLE_PROFILE_COUNT; i++) {
+    for (int i = 0; i < 8; i++) {
         char setting_name[15];
         sprintf(setting_name, "ble/profiles/%d", i);
 
@@ -615,7 +620,20 @@ static int zmk_ble_init(void) {
             LOG_ERR("Failed to delete setting: %d", err);
         }
     }
-#endif
+
+    // Hardcoding a reasonable hardcoded value of peripheral addresses
+    // to clear so we properly clear a split central as well.
+    for (int i = 0; i < 8; i++) {
+        char setting_name[32];
+        sprintf(setting_name, "ble/peripheral_addresses/%d", i);
+
+        err = settings_delete(setting_name);
+        if (err) {
+            LOG_ERR("Failed to delete setting: %d", err);
+        }
+    }
+
+#endif // IS_ENABLED(CONFIG_ZMK_BLE_CLEAR_BONDS_ON_START)
 
     bt_conn_cb_register(&conn_callbacks);
     bt_conn_auth_cb_register(&zmk_ble_auth_cb_display);
diff --git a/app/src/display/Kconfig b/app/src/display/Kconfig
index 63ba968..a202948 100644
--- a/app/src/display/Kconfig
+++ b/app/src/display/Kconfig
@@ -7,7 +7,6 @@ menuconfig ZMK_DISPLAY
     select DISPLAY
     select LVGL
     select LV_CONF_MINIMAL
-    imply LV_USE_THEME_MONO
 
 if ZMK_DISPLAY
 
@@ -42,6 +41,11 @@ choice ZMK_DISPLAY_STATUS_SCREEN
 config ZMK_DISPLAY_STATUS_SCREEN_BUILT_IN
     bool "Built in status screen"
     select LV_OBJ_LABEL
+    imply LV_USE_THEME_MONO
+    imply ZMK_WIDGET_LAYER_STATUS
+    imply ZMK_WIDGET_BATTERY_STATUS
+    imply ZMK_WIDGET_OUTPUT_STATUS
+    imply ZMK_WIDGET_PERIPHERAL_STATUS
 
 config ZMK_DISPLAY_STATUS_SCREEN_CUSTOM
     bool "Custom status screen"
diff --git a/app/src/display/widgets/Kconfig b/app/src/display/widgets/Kconfig
index 4c056cf..7ec20c1 100644
--- a/app/src/display/widgets/Kconfig
+++ b/app/src/display/widgets/Kconfig
@@ -5,14 +5,12 @@ menu "ZMK Display Widgets"
 
 config ZMK_WIDGET_LAYER_STATUS
     bool "Widget for highest, active layer using small icons"
-    default y
     depends on !ZMK_SPLIT || ZMK_SPLIT_ROLE_CENTRAL
     select LV_USE_LABEL
 
 config ZMK_WIDGET_BATTERY_STATUS
     bool "Widget for battery charge information, using small icons"
     depends on BT
-    default y if BT
     select LV_USE_LABEL
 
 if ZMK_WIDGET_BATTERY_STATUS
@@ -25,13 +23,11 @@ endif
 config ZMK_WIDGET_OUTPUT_STATUS
     bool "Widget for keyboard output status icons"
     depends on BT && (!ZMK_SPLIT_BLE || ZMK_SPLIT_ROLE_CENTRAL)
-    default y if BT && (!ZMK_SPLIT_BLE || ZMK_SPLIT_ROLE_CENTRAL)
     select LV_USE_LABEL
 
 config ZMK_WIDGET_PERIPHERAL_STATUS
     bool "Widget for split peripheral status icons"
     depends on BT && ZMK_SPLIT_BLE && !ZMK_SPLIT_ROLE_CENTRAL
-    default y if BT && ZMK_SPLIT_BLE && !ZMK_SPLIT_ROLE_CENTRAL
     select LV_USE_LABEL
 
 config ZMK_WIDGET_WPM_STATUS
diff --git a/app/src/keymap.c b/app/src/keymap.c
index 020faf3..bda6942 100644
--- a/app/src/keymap.c
+++ b/app/src/keymap.c
@@ -31,10 +31,6 @@ static uint8_t _zmk_keymap_layer_default = 0;
 
 #define DT_DRV_COMPAT zmk_keymap
 
-#define LAYER_CHILD_LEN(node) 1 +
-#define ZMK_KEYMAP_NODE DT_DRV_INST(0)
-#define ZMK_KEYMAP_LAYERS_LEN (DT_INST_FOREACH_CHILD(0, LAYER_CHILD_LEN) 0)
-
 #define BINDING_WITH_COMMA(idx, drv_inst) ZMK_KEYMAP_EXTRACT_BINDING(idx, drv_inst)
 
 #define TRANSFORMED_LAYER(node)                                                                    \
diff --git a/app/src/rgb_underglow.c b/app/src/rgb_underglow.c
index e18ce15..febe801 100644
--- a/app/src/rgb_underglow.c
+++ b/app/src/rgb_underglow.c
@@ -24,6 +24,7 @@
 #include <zmk/event_manager.h>
 #include <zmk/events/activity_state_changed.h>
 #include <zmk/events/usb_conn_state_changed.h>
+#include <zmk/workqueue.h>
 
 LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
 
@@ -196,14 +197,14 @@ static void zmk_rgb_underglow_tick(struct k_work *work) {
     }
 }
 
-K_WORK_DEFINE(underglow_work, zmk_rgb_underglow_tick);
+K_WORK_DEFINE(underglow_tick_work, zmk_rgb_underglow_tick);
 
 static void zmk_rgb_underglow_tick_handler(struct k_timer *timer) {
     if (!state.on) {
         return;
     }
 
-    k_work_submit(&underglow_work);
+    k_work_submit_to_queue(zmk_workqueue_lowprio_work_q(), &underglow_tick_work);
 }
 
 K_TIMER_DEFINE(underglow_tick, zmk_rgb_underglow_tick_handler, NULL);
@@ -322,6 +323,16 @@ int zmk_rgb_underglow_on() {
     return zmk_rgb_underglow_save_state();
 }
 
+static void zmk_rgb_underglow_off_handler(struct k_work *work) {
+    for (int i = 0; i < STRIP_NUM_PIXELS; i++) {
+        pixels[i] = (struct led_rgb){r : 0, g : 0, b : 0};
+    }
+
+    led_strip_update_rgb(led_strip, pixels, STRIP_NUM_PIXELS);
+}
+
+K_WORK_DEFINE(underglow_off_work, zmk_rgb_underglow_off_handler);
+
 int zmk_rgb_underglow_off() {
     if (!led_strip)
         return -ENODEV;
@@ -335,11 +346,7 @@ int zmk_rgb_underglow_off() {
     }
 #endif
 
-    for (int i = 0; i < STRIP_NUM_PIXELS; i++) {
-        pixels[i] = (struct led_rgb){r : 0, g : 0, b : 0};
-    }
-
-    led_strip_update_rgb(led_strip, pixels, STRIP_NUM_PIXELS);
+    k_work_submit_to_queue(zmk_workqueue_lowprio_work_q(), &underglow_off_work);
 
     k_timer_stop(&underglow_tick);
     state.on = false;
diff --git a/app/src/sensors.c b/app/src/sensors.c
index aa09048..34fd49e 100644
--- a/app/src/sensors.c
+++ b/app/src/sensors.c
@@ -29,7 +29,7 @@ struct sensors_item_cfg {
     {                                                                                              \
         .dev = DEVICE_DT_GET_OR_NULL(node),                                                        \
         .trigger = {.type = SENSOR_TRIG_DATA_READY, .chan = SENSOR_CHAN_ROTATION},                 \
-        .config = &configs[idx]                                                                    \
+        .config = &configs[idx], .sensor_index = idx                                               \
     }
 #define SENSOR_ITEM(idx, _i) _SENSOR_ITEM(idx, ZMK_KEYMAP_SENSORS_BY_IDX(idx))
 
@@ -112,7 +112,7 @@ static void zmk_sensors_trigger_handler(const struct device *dev,
     int sensor_index = test_item - sensors;
 
     if (sensor_index < 0 || sensor_index >= ARRAY_SIZE(sensors)) {
-        LOG_ERR("Invalid sensor item triggered our callback");
+        LOG_ERR("Invalid sensor item triggered our callback (%d)", sensor_index);
         return;
     }
 
@@ -127,8 +127,6 @@ static void zmk_sensors_trigger_handler(const struct device *dev,
 static void zmk_sensors_init_item(uint8_t i) {
     LOG_DBG("Init sensor at index %d", i);
 
-    sensors[i].sensor_index = i;
-
     if (!sensors[i].dev) {
         LOG_DBG("No local device for %d", i);
         return;
diff --git a/app/src/split/bluetooth/central.c b/app/src/split/bluetooth/central.c
index d3c3ee1..a8a1c60 100644
--- a/app/src/split/bluetooth/central.c
+++ b/app/src/split/bluetooth/central.c
@@ -21,10 +21,12 @@ LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
 #include <zmk/stdlib.h>
 #include <zmk/ble.h>
 #include <zmk/behavior.h>
+#include <zmk/sensors.h>
 #include <zmk/split/bluetooth/uuid.h>
 #include <zmk/split/bluetooth/service.h>
 #include <zmk/event_manager.h>
 #include <zmk/events/position_state_changed.h>
+#include <zmk/events/sensor_event.h>
 
 static int start_scanning(void);
 
@@ -41,6 +43,7 @@ struct peripheral_slot {
     struct bt_conn *conn;
     struct bt_gatt_discover_params discover_params;
     struct bt_gatt_subscribe_params subscribe_params;
+    struct bt_gatt_subscribe_params sensor_subscribe_params;
     struct bt_gatt_discover_params sub_discover_params;
     uint16_t run_behavior_handle;
     uint8_t position_state[POSITION_STATE_DATA_LEN];
@@ -165,6 +168,52 @@ int confirm_peripheral_slot_conn(struct bt_conn *conn) {
     return 0;
 }
 
+#if ZMK_KEYMAP_HAS_SENSORS
+K_MSGQ_DEFINE(peripheral_sensor_event_msgq, sizeof(struct zmk_sensor_event),
+              CONFIG_ZMK_SPLIT_BLE_CENTRAL_POSITION_QUEUE_SIZE, 4);
+
+void peripheral_sensor_event_work_callback(struct k_work *work) {
+    struct zmk_sensor_event ev;
+    while (k_msgq_get(&peripheral_sensor_event_msgq, &ev, K_NO_WAIT) == 0) {
+        LOG_DBG("Trigger sensor change for %d", ev.sensor_index);
+        ZMK_EVENT_RAISE(new_zmk_sensor_event(ev));
+    }
+}
+
+K_WORK_DEFINE(peripheral_sensor_event_work, peripheral_sensor_event_work_callback);
+
+static uint8_t split_central_sensor_notify_func(struct bt_conn *conn,
+                                                struct bt_gatt_subscribe_params *params,
+                                                const void *data, uint16_t length) {
+    if (!data) {
+        LOG_DBG("[UNSUBSCRIBED]");
+        params->value_handle = 0U;
+        return BT_GATT_ITER_STOP;
+    }
+
+    LOG_DBG("[SENSOR NOTIFICATION] data %p length %u", data, length);
+
+    if (length < offsetof(struct sensor_event, channel_data)) {
+        LOG_WRN("Ignoring sensor notify with insufficient data length (%d)", length);
+        return BT_GATT_ITER_STOP;
+    }
+
+    struct sensor_event sensor_event;
+    memcpy(&sensor_event, data, MIN(length, sizeof(sensor_event)));
+    struct zmk_sensor_event ev = {
+        .sensor_index = sensor_event.sensor_index,
+        .channel_data_size = MIN(sensor_event.channel_data_size, ZMK_SENSOR_EVENT_MAX_CHANNELS),
+        .timestamp = k_uptime_get()};
+
+    memcpy(ev.channel_data, sensor_event.channel_data,
+           sizeof(struct zmk_sensor_channel_data) * sensor_event.channel_data_size);
+    k_msgq_put(&peripheral_sensor_event_msgq, &ev, K_NO_WAIT);
+    k_work_submit(&peripheral_sensor_event_work);
+
+    return BT_GATT_ITER_CONTINUE;
+}
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
+
 static uint8_t split_central_notify_func(struct bt_conn *conn,
                                          struct bt_gatt_subscribe_params *params, const void *data,
                                          uint16_t length) {
@@ -209,14 +258,8 @@ static uint8_t split_central_notify_func(struct bt_conn *conn,
     return BT_GATT_ITER_CONTINUE;
 }
 
-static void split_central_subscribe(struct bt_conn *conn) {
-    struct peripheral_slot *slot = peripheral_slot_for_conn(conn);
-    if (slot == NULL) {
-        LOG_ERR("No peripheral state found for connection");
-        return;
-    }
-
-    int err = bt_gatt_subscribe(conn, &slot->subscribe_params);
+static int split_central_subscribe(struct bt_conn *conn, struct bt_gatt_subscribe_params *params) {
+    int err = bt_gatt_subscribe(conn, params);
     switch (err) {
     case -EALREADY:
         LOG_DBG("[ALREADY SUBSCRIBED]");
@@ -228,6 +271,8 @@ static void split_central_subscribe(struct bt_conn *conn) {
         LOG_ERR("Subscribe failed (err %d)", err);
         break;
     }
+
+    return err;
 }
 
 static uint8_t split_central_chrc_discovery_func(struct bt_conn *conn,
@@ -250,9 +295,9 @@ static uint8_t split_central_chrc_discovery_func(struct bt_conn *conn,
     }
 
     LOG_DBG("[ATTRIBUTE] handle %u", attr->handle);
+    const struct bt_uuid *chrc_uuid = ((struct bt_gatt_chrc *)attr->user_data)->uuid;
 
-    if (!bt_uuid_cmp(((struct bt_gatt_chrc *)attr->user_data)->uuid,
-                     BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_POSITION_STATE_UUID))) {
+    if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_POSITION_STATE_UUID)) == 0) {
         LOG_DBG("Found position state characteristic");
         slot->discover_params.uuid = NULL;
         slot->discover_params.start_handle = attr->handle + 2;
@@ -263,14 +308,33 @@ static uint8_t split_central_chrc_discovery_func(struct bt_conn *conn,
         slot->subscribe_params.value_handle = bt_gatt_attr_value_handle(attr);
         slot->subscribe_params.notify = split_central_notify_func;
         slot->subscribe_params.value = BT_GATT_CCC_NOTIFY;
-        split_central_subscribe(conn);
-    } else if (!bt_uuid_cmp(((struct bt_gatt_chrc *)attr->user_data)->uuid,
-                            BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_RUN_BEHAVIOR_UUID))) {
+        split_central_subscribe(conn, &slot->subscribe_params);
+#if ZMK_KEYMAP_HAS_SENSORS
+    } else if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_SENSOR_STATE_UUID)) ==
+               0) {
+        slot->discover_params.uuid = NULL;
+        slot->discover_params.start_handle = attr->handle + 2;
+        slot->discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
+
+        slot->sensor_subscribe_params.disc_params = &slot->sub_discover_params;
+        slot->sensor_subscribe_params.end_handle = slot->discover_params.end_handle;
+        slot->sensor_subscribe_params.value_handle = bt_gatt_attr_value_handle(attr);
+        slot->sensor_subscribe_params.notify = split_central_sensor_notify_func;
+        slot->sensor_subscribe_params.value = BT_GATT_CCC_NOTIFY;
+        split_central_subscribe(conn, &slot->sensor_subscribe_params);
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
+    } else if (bt_uuid_cmp(chrc_uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_RUN_BEHAVIOR_UUID)) ==
+               0) {
         LOG_DBG("Found run behavior handle");
+        slot->discover_params.uuid = NULL;
+        slot->discover_params.start_handle = attr->handle + 2;
         slot->run_behavior_handle = bt_gatt_attr_value_handle(attr);
     }
 
-    bool subscribed = (slot->run_behavior_handle && slot->subscribe_params.value_handle);
+    bool subscribed = slot->run_behavior_handle && slot->subscribe_params.value_handle;
+#if ZMK_KEYMAP_HAS_SENSORS
+    subscribed = subscribed && slot->sensor_subscribe_params.value_handle;
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
 
     return subscribed ? BT_GATT_ITER_STOP : BT_GATT_ITER_CONTINUE;
 }
@@ -292,7 +356,8 @@ static uint8_t split_central_service_discovery_func(struct bt_conn *conn,
         return BT_GATT_ITER_STOP;
     }
 
-    if (bt_uuid_cmp(slot->discover_params.uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID))) {
+    if (bt_uuid_cmp(slot->discover_params.uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID)) !=
+        0) {
         LOG_DBG("Found other service");
         return BT_GATT_ITER_CONTINUE;
     }
@@ -418,7 +483,7 @@ static bool split_central_eir_parse(struct bt_data *data, void *user_data) {
                 continue;
             }
 
-            if (bt_uuid_cmp(&uuid.uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID))) {
+            if (bt_uuid_cmp(&uuid.uuid, BT_UUID_DECLARE_128(ZMK_SPLIT_BT_SERVICE_UUID)) != 0) {
                 char uuid_str[BT_UUID_STR_LEN];
                 char service_uuid_str[BT_UUID_STR_LEN];
 
diff --git a/app/src/split/bluetooth/peripheral.c b/app/src/split/bluetooth/peripheral.c
index f3cdd8f..eb6725f 100644
--- a/app/src/split/bluetooth/peripheral.c
+++ b/app/src/split/bluetooth/peripheral.c
@@ -18,7 +18,7 @@
 #include <zephyr/bluetooth/hci.h>
 #include <zephyr/bluetooth/uuid.h>
 #include <zephyr/bluetooth/gatt.h>
-#include <zephyr/bluetooth/hci_types.h>
+#include <zephyr/bluetooth/hci_err.h>
 
 #if IS_ENABLED(CONFIG_SETTINGS)
 
@@ -116,11 +116,11 @@ static int zmk_peripheral_ble_init(void) {
     LOG_WRN("Clearing all existing BLE bond information from the keyboard");
 
     bt_unpair(BT_ID_DEFAULT, NULL);
-#endif
-
+#else
     bt_conn_cb_register(&conn_callbacks);
 
     start_advertising();
+#endif
 
     return 0;
 }
diff --git a/app/src/split/bluetooth/service.c b/app/src/split/bluetooth/service.c
index 378b2c5..fc174d2 100644
--- a/app/src/split/bluetooth/service.c
+++ b/app/src/split/bluetooth/service.c
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier: MIT
  */
 
+#include <zephyr/drivers/sensor.h>
 #include <zephyr/types.h>
 #include <zephyr/sys/util.h>
 #include <zephyr/init.h>
@@ -20,6 +21,22 @@ LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
 #include <zmk/matrix.h>
 #include <zmk/split/bluetooth/uuid.h>
 #include <zmk/split/bluetooth/service.h>
+#include <zmk/events/sensor_event.h>
+#include <zmk/sensors.h>
+
+#if ZMK_KEYMAP_HAS_SENSORS
+static struct sensor_event last_sensor_event;
+
+static ssize_t split_svc_sensor_state(struct bt_conn *conn, const struct bt_gatt_attr *attrs,
+                                      void *buf, uint16_t len, uint16_t offset) {
+    return bt_gatt_attr_read(conn, attrs, buf, len, offset, &last_sensor_event,
+                             sizeof(last_sensor_event));
+}
+
+static void split_svc_sensor_state_ccc(const struct bt_gatt_attr *attr, uint16_t value) {
+    LOG_DBG("value %d", value);
+}
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
 
 #define POS_STATE_LEN 16
 
@@ -98,7 +115,14 @@ BT_GATT_SERVICE_DEFINE(
                            BT_GATT_CHRC_WRITE_WITHOUT_RESP, BT_GATT_PERM_WRITE_ENCRYPT, NULL,
                            split_svc_run_behavior, &behavior_run_payload),
     BT_GATT_DESCRIPTOR(BT_UUID_NUM_OF_DIGITALS, BT_GATT_PERM_READ, split_svc_num_of_positions, NULL,
-                       &num_of_positions), );
+                       &num_of_positions),
+#if ZMK_KEYMAP_HAS_SENSORS
+    BT_GATT_CHARACTERISTIC(BT_UUID_DECLARE_128(ZMK_SPLIT_BT_CHAR_SENSOR_STATE_UUID),
+                           BT_GATT_CHRC_READ | BT_GATT_CHRC_NOTIFY, BT_GATT_PERM_READ_ENCRYPT,
+                           split_svc_sensor_state, NULL, &last_sensor_event),
+    BT_GATT_CCC(split_svc_sensor_state_ccc, BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_WRITE_ENCRYPT),
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
+);
 
 K_THREAD_STACK_DEFINE(service_q_stack, CONFIG_ZMK_SPLIT_BLE_PERIPHERAL_STACK_SIZE);
 
@@ -151,6 +175,58 @@ int zmk_split_bt_position_released(uint8_t position) {
     return send_position_state();
 }
 
+#if ZMK_KEYMAP_HAS_SENSORS
+K_MSGQ_DEFINE(sensor_state_msgq, sizeof(struct sensor_event),
+              CONFIG_ZMK_SPLIT_BLE_PERIPHERAL_POSITION_QUEUE_SIZE, 4);
+
+void send_sensor_state_callback(struct k_work *work) {
+    while (k_msgq_get(&sensor_state_msgq, &last_sensor_event, K_NO_WAIT) == 0) {
+        int err = bt_gatt_notify(NULL, &split_svc.attrs[8], &last_sensor_event,
+                                 sizeof(last_sensor_event));
+        if (err) {
+            LOG_DBG("Error notifying %d", err);
+        }
+    }
+};
+
+K_WORK_DEFINE(service_sensor_notify_work, send_sensor_state_callback);
+
+int send_sensor_state(struct sensor_event ev) {
+    int err = k_msgq_put(&sensor_state_msgq, &ev, K_MSEC(100));
+    if (err) {
+        // retry...
+        switch (err) {
+        case -EAGAIN: {
+            LOG_WRN("Sensor state message queue full, popping first message and queueing again");
+            struct sensor_event discarded_state;
+            k_msgq_get(&sensor_state_msgq, &discarded_state, K_NO_WAIT);
+            return send_sensor_state(ev);
+        }
+        default:
+            LOG_WRN("Failed to queue sensor state to send (%d)", err);
+            return err;
+        }
+    }
+
+    k_work_submit_to_queue(&service_work_q, &service_sensor_notify_work);
+    return 0;
+}
+
+int zmk_split_bt_sensor_triggered(uint8_t sensor_index,
+                                  const struct zmk_sensor_channel_data channel_data[],
+                                  size_t channel_data_size) {
+    if (channel_data_size > ZMK_SENSOR_EVENT_MAX_CHANNELS) {
+        return -EINVAL;
+    }
+
+    struct sensor_event ev =
+        (struct sensor_event){.sensor_index = sensor_index, .channel_data_size = channel_data_size};
+    memcpy(ev.channel_data, channel_data,
+           channel_data_size * sizeof(struct zmk_sensor_channel_data));
+    return send_sensor_state(ev);
+}
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
+
 static int service_init(void) {
     static const struct k_work_queue_config queue_config = {
         .name = "Split Peripheral Notification Queue"};
diff --git a/app/src/split/bluetooth/split_listener.c b/app/src/split/bluetooth/split_listener.c
index eb5398c..9b680d2 100644
--- a/app/src/split/bluetooth/split_listener.c
+++ b/app/src/split/bluetooth/split_listener.c
@@ -13,21 +13,35 @@ LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);
 
 #include <zmk/event_manager.h>
 #include <zmk/events/position_state_changed.h>
+#include <zmk/events/sensor_event.h>
 #include <zmk/hid.h>
+#include <zmk/sensors.h>
 #include <zmk/endpoints.h>
 
 int split_listener(const zmk_event_t *eh) {
     LOG_DBG("");
-    const struct zmk_position_state_changed *ev = as_zmk_position_state_changed(eh);
-    if (ev != NULL) {
-        if (ev->state) {
-            return zmk_split_bt_position_pressed(ev->position);
+    const struct zmk_position_state_changed *pos_ev;
+    if ((pos_ev = as_zmk_position_state_changed(eh)) != NULL) {
+        if (pos_ev->state) {
+            return zmk_split_bt_position_pressed(pos_ev->position);
         } else {
-            return zmk_split_bt_position_released(ev->position);
+            return zmk_split_bt_position_released(pos_ev->position);
         }
     }
+
+#if ZMK_KEYMAP_HAS_SENSORS
+    const struct zmk_sensor_event *sensor_ev;
+    if ((sensor_ev = as_zmk_sensor_event(eh)) != NULL) {
+        return zmk_split_bt_sensor_triggered(sensor_ev->sensor_index, sensor_ev->channel_data,
+                                             sensor_ev->channel_data_size);
+    }
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
     return ZMK_EV_EVENT_BUBBLE;
 }
 
 ZMK_LISTENER(split_listener, split_listener);
-ZMK_SUBSCRIPTION(split_listener, zmk_position_state_changed);
\ No newline at end of file
+ZMK_SUBSCRIPTION(split_listener, zmk_position_state_changed);
+
+#if ZMK_KEYMAP_HAS_SENSORS
+ZMK_SUBSCRIPTION(split_listener, zmk_sensor_event);
+#endif /* ZMK_KEYMAP_HAS_SENSORS */
diff --git a/app/src/workqueue.c b/app/src/workqueue.c
new file mode 100644
index 0000000..a9a8bce
--- /dev/null
+++ b/app/src/workqueue.c
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2023 The ZMK Contributors
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#include <zephyr/kernel.h>
+#include <zephyr/device.h>
+
+#include <zmk/workqueue.h>
+
+K_THREAD_STACK_DEFINE(lowprio_q_stack, CONFIG_ZMK_LOW_PRIORITY_THREAD_STACK_SIZE);
+
+static struct k_work_q lowprio_work_q;
+
+struct k_work_q *zmk_workqueue_lowprio_work_q() {
+    return &lowprio_work_q;
+}
+
+static int workqueue_init() {
+    static const struct k_work_queue_config queue_config = {.name = "Low Priority Work Queue"};
+    k_work_queue_start(&lowprio_work_q, lowprio_q_stack, K_THREAD_STACK_SIZEOF(lowprio_q_stack),
+                       CONFIG_ZMK_LOW_PRIORITY_THREAD_PRIORITY, &queue_config);
+    return 0;
+}
+
+SYS_INIT(workqueue_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
