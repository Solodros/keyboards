diff --git a/keychron_bluetooth_playground b/keychron_bluetooth_playground
new file mode 100644
index 0000000000..86cc903770
--- /dev/null
+++ b/keychron_bluetooth_playground
@@ -0,0 +1 @@
+keychron_bluetooth_playgrounddiff --git a/data/schemas/keyboard.jsonschema b/data/schemas/keyboard.jsonschema
index 91110b06a0..c207f42f07 100644
--- a/data/schemas/keyboard.jsonschema
+++ b/data/schemas/keyboard.jsonschema
@@ -127,7 +127,7 @@
             "properties": {
                 "driver": {
                     "type": "string",
-                    "enum": ["BluefruitLE", "RN42"]
+                    "enum": ["BluefruitLE", "RN42", "custom"]
                 }
             }
         },
diff --git a/quantum/rgb_matrix/rgb_matrix.c b/quantum/rgb_matrix/rgb_matrix.c
index e7125bb87f..983495c7cd 100644
--- a/quantum/rgb_matrix/rgb_matrix.c
+++ b/quantum/rgb_matrix/rgb_matrix.c
@@ -117,6 +117,9 @@ last_hit_t g_last_hit_tracker;
 #endif // RGB_MATRIX_KEYREACTIVE_ENABLED

 // internals
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+static bool            driver_shutdown   = false;
+#endif
 static bool            suspend_state     = false;
 static uint8_t         rgb_last_enable   = UINT8_MAX;
 static uint8_t         rgb_last_effect   = UINT8_MAX;
@@ -124,6 +127,7 @@ static effect_params_t rgb_effect_params = {0, LED_FLAG_ALL, false};
 static rgb_task_states rgb_task_state    = SYNCING;
 #if RGB_MATRIX_TIMEOUT > 0
 static uint32_t rgb_anykey_timer;
+static uint32_t rgb_matrix_timeout = RGB_MATRIX_TIMEOUT;
 #endif // RGB_MATRIX_TIMEOUT > 0

 // double buffers
@@ -282,12 +286,22 @@ void rgb_matrix_test(void) {
     }
 }

+void rgb_matrix_none_indicators(void) {
+    rgb_matrix_none_indicators_kb();
+    rgb_matrix_none_indicators_user();
+}
+
+__attribute__((weak)) void rgb_matrix_none_indicators_kb(void) {}
+
+__attribute__((weak)) void rgb_matrix_none_indicators_user(void) {}
+
 static bool rgb_matrix_none(effect_params_t *params) {
     if (!params->init) {
         return false;
     }

     rgb_matrix_set_color_all(0, 0, 0);
+    rgb_matrix_none_indicators();
     return false;
 }

@@ -401,9 +415,22 @@ static void rgb_task_flush(uint8_t effect) {
     // update last trackers after the first full render so we can init over several frames
     rgb_last_effect = effect;
     rgb_last_enable = rgb_matrix_config.enable;
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+    // exit from shutdown to if neccesary
+    if (driver_shutdown)  {
+        rgb_matrix_driver.exit_shutdown();
+        driver_shutdown = false;
+    }
+#endif

     // update pwm buffers
     rgb_matrix_update_pwm_buffers();
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+    // shutdown to if neccesary
+    if (effect == RGB_MATRIX_NONE && !driver_shutdown && rgb_matrix_driver_allow_shutdown()) {
+        rgb_matrix_driver_shutdown();
+    }
+#endif

     // next task
     rgb_task_state = SYNCING;
@@ -416,7 +443,7 @@ void rgb_matrix_task(void) {
     // while suspended and just do a software shutdown. This is a cheap hack for now.
     bool suspend_backlight = suspend_state ||
 #if RGB_MATRIX_TIMEOUT > 0
-                             (rgb_anykey_timer > (uint32_t)RGB_MATRIX_TIMEOUT) ||
+                             (rgb_anykey_timer > rgb_matrix_timeout) ||
 #endif // RGB_MATRIX_TIMEOUT > 0
                              false;

@@ -481,6 +508,9 @@ __attribute__((weak)) bool rgb_matrix_indicators_advanced_user(uint8_t led_min,

 void rgb_matrix_init(void) {
     rgb_matrix_driver.init();
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+    driver_shutdown = false;
+#endif

 #ifdef RGB_MATRIX_KEYREACTIVE_ENABLED
     g_last_hit_tracker.count = 0;
@@ -750,3 +780,20 @@ void rgb_matrix_set_flags(led_flags_t flags) {
 void rgb_matrix_set_flags_noeeprom(led_flags_t flags) {
     rgb_matrix_set_flags_eeprom_helper(flags, false);
 }
+#if RGB_DISABLE_TIMEOUT > 0
+void rgb_matrix_timeout_set(uint32_t timeout) {
+    rgb_matrix_timeout = timeout;
+}
+void rgb_matrix_time_reset(void){ rgb_anykey_timer = 0; }
+#endif
+
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+void rgb_matrix_driver_shutdown(void) {
+    rgb_matrix_driver.shutdown();
+    driver_shutdown = true;
+};
+
+bool rgb_matrix_is_driver_shutdown(void) { return driver_shutdown; }
+
+__attribute__((weak)) bool rgb_matrix_driver_allow_shutdown(void) { return true; };
+#endif
diff --git a/quantum/rgb_matrix/rgb_matrix.h b/quantum/rgb_matrix/rgb_matrix.h
index 62078f6e60..df676cefec 100644
--- a/quantum/rgb_matrix/rgb_matrix.h
+++ b/quantum/rgb_matrix/rgb_matrix.h
@@ -88,6 +88,8 @@
 #define RGB_MATRIX_TEST_LED_FLAGS() \
     if (!HAS_ANY_FLAGS(g_led_config.flags[i], params->flags)) continue

+#define RGB_MATRIX_TIME_INFINITE   (UINT32_MAX)
+
 enum rgb_matrix_effects {
     RGB_MATRIX_NONE = 0,

@@ -125,6 +127,8 @@ void rgb_matrix_set_color_all(uint8_t red, uint8_t green, uint8_t blue);
 void process_rgb_matrix(uint8_t row, uint8_t col, bool pressed);

 void rgb_matrix_task(void);
+void rgb_matrix_none_indicators_kb(void);
+void rgb_matrix_none_indicators_user(void);

 // This runs after another backlight effect and replaces
 // colors already set
@@ -184,6 +188,17 @@ void        rgb_matrix_decrease_speed_noeeprom(void);
 led_flags_t rgb_matrix_get_flags(void);
 void        rgb_matrix_set_flags(led_flags_t flags);
 void        rgb_matrix_set_flags_noeeprom(led_flags_t flags);
+#ifdef RGB_MATRIX_TIMEOUT
+#   if RGB_MATRIX_TIMEOUT > 0
+void        rgb_matrix_timeout_set(uint32_t timeout);
+void        rgb_matrix_time_reset(void);
+#   endif
+#endif
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+void        rgb_matrix_driver_shutdown(void);
+bool        rgb_matrix_is_driver_shutdown(void);
+bool        rgb_matrix_driver_allow_shutdown(void);
+#endif

 #ifndef RGBLIGHT_ENABLE
 #    define eeconfig_update_rgblight_current eeconfig_update_rgb_matrix
@@ -238,6 +253,12 @@ typedef struct {
     void (*set_color_all)(uint8_t r, uint8_t g, uint8_t b);
     /* Flush any buffered changes to the hardware. */
     void (*flush)(void);
+#ifdef RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE
+    /* Shutdown the driver. */
+    void (*shutdown)(void);
+    /* Exit from shutdown state. */
+    void (*exit_shutdown)(void);
+#endif
 } rgb_matrix_driver_t;

 static inline bool rgb_matrix_check_finished_leds(uint8_t led_idx) {
diff --git a/quantum/rgb_matrix/rgb_matrix_drivers.c b/quantum/rgb_matrix/rgb_matrix_drivers.c
index 5b81915845..015e256d37 100644
--- a/quantum/rgb_matrix/rgb_matrix_drivers.c
+++ b/quantum/rgb_matrix/rgb_matrix_drivers.c
@@ -100,6 +100,10 @@ static void init(void) {
 #        endif

 #    elif defined(CKLED2001)
+#        if defined(LED_DRIVER_SHUTDOWN_PIN)
+    setPinOutput(LED_DRIVER_SHUTDOWN_PIN);
+    writePinHigh(LED_DRIVER_SHUTDOWN_PIN);
+#        endif
     CKLED2001_init(DRIVER_ADDR_1);
 #        if defined(DRIVER_ADDR_2)
     CKLED2001_init(DRIVER_ADDR_2);
@@ -313,11 +317,51 @@ static void flush(void) {
 #        endif
 }

+#        if defined(RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE)
+static void shutdown(void) {
+#           if defined(LED_DRIVER_SHUTDOWN_PIN)
+    writePinLow(LED_DRIVER_SHUTDOWN_PIN);
+#           else
+    CKLED2001_sw_shutdown(DRIVER_ADDR_1);
+#               if defined(DRIVER_ADDR_2)
+    CKLED2001_sw_shutdown(DRIVER_ADDR_2);
+#                   if defined(DRIVER_ADDR_3)
+    CKLED2001_sw_shutdown(DRIVER_ADDR_3);
+#                       if defined(DRIVER_ADDR_4)
+    CKLED2001_sw_shutdown(DRIVER_ADDR_4);
+#                       endif
+#                   endif
+#               endif
+#           endif
+}
+
+static void exit_shutdown(void) {
+#           if defined(LED_DRIVER_SHUTDOWN_PIN)
+    writePinHigh(LED_DRIVER_SHUTDOWN_PIN);
+#           else
+    CKLED2001_sw_return_normal(DRIVER_ADDR_1);
+#               if defined(DRIVER_ADDR_2)
+    CKLED2001_sw_return_normal(DRIVER_ADDR_2);
+#                   if defined(DRIVER_ADDR_3)
+    CKLED2001_sw_return_normal(DRIVER_ADDR_3);
+#                       if defined(DRIVER_ADDR_4)
+    CKLED2001_sw_return_normal(DRIVER_ADDR_4);
+#                       endif
+#                   endif
+#               endif
+#           endif
+}
+#       endif
+
 const rgb_matrix_driver_t rgb_matrix_driver = {
     .init = init,
     .flush = flush,
     .set_color = CKLED2001_set_color,
     .set_color_all = CKLED2001_set_color_all,
+#        if defined(RGB_MATRIX_DRIVER_SHUTDOWN_ENABLE)
+    .shutdown = shutdown,
+    .exit_shutdown = exit_shutdown
+#        endif
 };
 #    endif

diff --git a/tmk_core/protocol.mk b/tmk_core/protocol.mk
index d3f15c4588..de97e2aec5 100644
--- a/tmk_core/protocol.mk
+++ b/tmk_core/protocol.mk
@@ -48,8 +48,6 @@ endif
 ifeq ($(strip $(NKRO_ENABLE)), yes)
     ifeq ($(PROTOCOL), VUSB)
         $(info NKRO is not currently supported on V-USB, and has been disabled.)
-    else ifeq ($(strip $(BLUETOOTH_ENABLE)), yes)
-        $(info NKRO is not currently supported with Bluetooth, and has been disabled.)
     else
         TMK_COMMON_DEFS += -DNKRO_ENABLE
         SHARED_EP_ENABLE = yes
diff --git a/tmk_core/protocol/chibios/chibios.c b/tmk_core/protocol/chibios/chibios.c
index 10a976608a..b5e39e0215 100644
--- a/tmk_core/protocol/chibios/chibios.c
+++ b/tmk_core/protocol/chibios/chibios.c
@@ -189,7 +189,7 @@ void protocol_pre_task(void) {
             /* Remote wakeup */
             if (suspend_wakeup_condition()) {
                 usbWakeupHost(&USB_DRIVER);
-                restart_usb_driver(&USB_DRIVER);
+                usb_wakeup(&USB_DRIVER);
             }
         }
         /* Woken up */
diff --git a/tmk_core/protocol/chibios/usb_driver.c b/tmk_core/protocol/chibios/usb_driver.c
index ad45f9b1da..0e3f28e3ea 100644
--- a/tmk_core/protocol/chibios/usb_driver.c
+++ b/tmk_core/protocol/chibios/usb_driver.c
@@ -408,7 +408,7 @@ void qmkusbDataTransmitted(USBDriver *usbp, usbep_t ep) {
            size. Otherwise the recipient may expect more data coming soon and
            not return buffered data to app. See section 5.8.3 Bulk Transfer
            Packet Size Constraints of the USB Specification document.*/
-        if (!qmkusbp->config->fixed_size) {
+        if (!qmkusbp->config->fixed_size && (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_BULK) {
             usbStartTransmitI(usbp, ep, usbp->setup, 0);
         }

diff --git a/tmk_core/protocol/chibios/usb_main.c b/tmk_core/protocol/chibios/usb_main.c
index 62a11faff7..1c4af2b877 100644
--- a/tmk_core/protocol/chibios/usb_main.c
+++ b/tmk_core/protocol/chibios/usb_main.c
@@ -665,8 +665,7 @@ static bool usb_request_hook_cb(USBDriver *usbp) {
                         if ((usbp->setup[4] == KEYBOARD_INTERFACE) && (usbp->setup[5] == 0)) { /* wIndex */
                             keyboard_protocol = ((usbp->setup[2]) != 0x00);                    /* LSB(wValue) */
 #ifdef NKRO_ENABLE
-                            keymap_config.nkro = !!keyboard_protocol;
-                            if (!keymap_config.nkro && keyboard_idle) {
+                            if (!keyboard_protocol && keyboard_idle) {
 #else  /* NKRO_ENABLE */
                             if (keyboard_idle) {
 #endif /* NKRO_ENABLE */
@@ -771,18 +770,19 @@ void init_usb_driver(USBDriver *usbp) {
     chVTObjectInit(&keyboard_idle_timer);
 }

-__attribute__((weak)) void restart_usb_driver(USBDriver *usbp) {
-    usbDisconnectBus(usbp);
-    usbStop(usbp);
+__attribute__((weak)) void usb_wakeup(USBDriver *usbp) {
+#if STM32_USB_USE_OTG1 || STM32_USB_USE_OTG1
+    stm32_otg_t *otgp = usbp->otg;

-#if USB_SUSPEND_WAKEUP_DELAY > 0
-    // Some hubs, kvm switches, and monitors do
-    // weird things, with USB device state bouncing
-    // around wildly on wakeup, yielding race
-    // conditions that can corrupt the keyboard state.
-    //
-    // Pause for a while to let things settle...
-    wait_ms(USB_SUSPEND_WAKEUP_DELAY);
+    osalSysLock();
+    /* If clocks are gated off, turn them back on (may be the case if
+     coming out of suspend mode).*/
+    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
+        /* Set to zero to un-gate the USB core clocks.*/
+        otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
+    }
+    _usb_wakeup(usbp);
+    osalSysUnlock();
 #endif

     usbStart(usbp, &usbcfg);
diff --git a/tmk_core/protocol/chibios/usb_main.h b/tmk_core/protocol/chibios/usb_main.h
index 07186f76b8..70b9112183 100644
--- a/tmk_core/protocol/chibios/usb_main.h
+++ b/tmk_core/protocol/chibios/usb_main.h
@@ -33,8 +33,11 @@
 /* Initialize the USB driver and bus */
 void init_usb_driver(USBDriver *usbp);

-/* Restart the USB driver and bus */
-void restart_usb_driver(USBDriver *usbp);
+/* Wakeup the USB driver */
+void usb_wakeup(USBDriver *usbp);
+
+/* Start the USB driver */
+void usb_start(USBDriver *usbp);

 /* ---------------
  * USB Event queue
diff --git a/tmk_core/protocol/host.h b/tmk_core/protocol/host.h
index dfa86cd7b5..6e73bd17e0 100644
--- a/tmk_core/protocol/host.h
+++ b/tmk_core/protocol/host.h
@@ -35,6 +35,7 @@ extern "C" {

 extern uint8_t keyboard_idle;
 extern uint8_t keyboard_protocol;
+extern uint8_t bluetooth_report_protocol;

 /* host driver */
 void           host_set_driver(host_driver_t *driver);
diff --git a/tmk_core/protocol/report.c b/tmk_core/protocol/report.c
index 5755098c60..9922e835be 100644
--- a/tmk_core/protocol/report.c
+++ b/tmk_core/protocol/report.c
@@ -20,6 +20,9 @@
 #include "debug.h"
 #include "util.h"
 #include <string.h>
+#ifdef BLUETOOTH_ENABLE
+#include "transport.h"
+#endif

 #ifdef RING_BUFFERED_6KRO_REPORT_ENABLE
 #    define RO_ADD(a, b) ((a + b) % KEYBOARD_REPORT_KEYS)
@@ -40,7 +43,14 @@ uint8_t has_anykey(report_keyboard_t* keyboard_report) {
     uint8_t* p   = keyboard_report->keys;
     uint8_t  lp  = sizeof(keyboard_report->keys);
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
+
         p  = keyboard_report->nkro.bits;
         lp = sizeof(keyboard_report->nkro.bits);
     }
@@ -57,7 +67,13 @@ uint8_t has_anykey(report_keyboard_t* keyboard_report) {
  */
 uint8_t get_first_key(report_keyboard_t* keyboard_report) {
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         uint8_t i = 0;
         for (; i < KEYBOARD_REPORT_BITS && !keyboard_report->nkro.bits[i]; i++)
             ;
@@ -88,7 +104,13 @@ bool is_key_pressed(report_keyboard_t* keyboard_report, uint8_t key) {
         return false;
     }
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         if ((key >> 3) < KEYBOARD_REPORT_BITS) {
             return keyboard_report->nkro.bits[key >> 3] & 1 << (key & 7);
         } else {
@@ -242,7 +264,13 @@ void del_key_bit(report_keyboard_t* keyboard_report, uint8_t code) {
  */
 void add_key_to_report(report_keyboard_t* keyboard_report, uint8_t key) {
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         add_key_bit(keyboard_report, key);
         return;
     }
@@ -256,7 +284,13 @@ void add_key_to_report(report_keyboard_t* keyboard_report, uint8_t key) {
  */
 void del_key_from_report(report_keyboard_t* keyboard_report, uint8_t key) {
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         del_key_bit(keyboard_report, key);
         return;
     }
@@ -271,7 +305,13 @@ void del_key_from_report(report_keyboard_t* keyboard_report, uint8_t key) {
 void clear_keys_from_report(report_keyboard_t* keyboard_report) {
     // not clear mods
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         memset(keyboard_report->nkro.bits, 0, sizeof(keyboard_report->nkro.bits));
         return;
     }
