diff --git a/keychron_bluetooth_playground b/keychron_bluetooth_playground
new file mode 100644
index 0000000000..86cc903770
--- /dev/null
+++ b/keychron_bluetooth_playground
@@ -0,0 +1,1 @@
+keychron_bluetooth_playground
diff --git a/tmk_core/protocol.mk b/tmk_core/protocol.mk
index 19fd7d2425..4ebdc7d8fd 100644
--- a/tmk_core/protocol.mk
+++ b/tmk_core/protocol.mk
@@ -48,8 +48,6 @@ endif
 ifeq ($(strip $(NKRO_ENABLE)), yes)
     ifeq ($(PROTOCOL), VUSB)
         $(info NKRO is not currently supported on V-USB, and has been disabled.)
-    else ifeq ($(strip $(BLUETOOTH_ENABLE)), yes)
-        $(info NKRO is not currently supported with Bluetooth, and has been disabled.)
     else
         TMK_COMMON_DEFS += -DNKRO_ENABLE
         SHARED_EP_ENABLE = yes
diff --git a/tmk_core/protocol/chibios/chibios.c b/tmk_core/protocol/chibios/chibios.c
index c9a480c325..05aa5104ee 100644
--- a/tmk_core/protocol/chibios/chibios.c
+++ b/tmk_core/protocol/chibios/chibios.c
@@ -192,7 +192,7 @@ void protocol_pre_task(void) {
             /* Remote wakeup */
             if (suspend_wakeup_condition()) {
                 usbWakeupHost(&USB_DRIVER);
-                restart_usb_driver(&USB_DRIVER);
+                usb_wakeup(&USB_DRIVER);
             }
         }
         /* Woken up */
diff --git a/tmk_core/protocol/chibios/usb_driver.c b/tmk_core/protocol/chibios/usb_driver.c
index ad45f9b1da..0e3f28e3ea 100644
--- a/tmk_core/protocol/chibios/usb_driver.c
+++ b/tmk_core/protocol/chibios/usb_driver.c
@@ -408,7 +408,7 @@ void qmkusbDataTransmitted(USBDriver *usbp, usbep_t ep) {
            size. Otherwise the recipient may expect more data coming soon and
            not return buffered data to app. See section 5.8.3 Bulk Transfer
            Packet Size Constraints of the USB Specification document.*/
-        if (!qmkusbp->config->fixed_size) {
+        if (!qmkusbp->config->fixed_size && (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_BULK) {
             usbStartTransmitI(usbp, ep, usbp->setup, 0);
         }

diff --git a/tmk_core/protocol/chibios/usb_main.c b/tmk_core/protocol/chibios/usb_main.c
index eb9ef82554..b6cef9acf9 100644
--- a/tmk_core/protocol/chibios/usb_main.c
+++ b/tmk_core/protocol/chibios/usb_main.c
@@ -639,8 +639,7 @@ static bool usb_request_hook_cb(USBDriver *usbp) {
                         if ((usbp->setup[4] == KEYBOARD_INTERFACE) && (usbp->setup[5] == 0)) { /* wIndex */
                             keyboard_protocol = ((usbp->setup[2]) != 0x00);                    /* LSB(wValue) */
 #ifdef NKRO_ENABLE
-                            keymap_config.nkro = !!keyboard_protocol;
-                            if (!keymap_config.nkro && keyboard_idle) {
+                            if (!keyboard_protocol && keyboard_idle) {
 #else  /* NKRO_ENABLE */
                             if (keyboard_idle) {
 #endif /* NKRO_ENABLE */
@@ -745,20 +744,23 @@ void init_usb_driver(USBDriver *usbp) {
     chVTObjectInit(&keyboard_idle_timer);
 }

-__attribute__((weak)) void restart_usb_driver(USBDriver *usbp) {
-    usbStop(usbp);
-    usbDisconnectBus(usbp);
+__attribute__((weak)) void usb_wakeup(USBDriver *usbp) {
+#if STM32_USB_USE_OTG1 || STM32_USB_USE_OTG1
+    stm32_otg_t *otgp = usbp->otg;

-#if USB_SUSPEND_WAKEUP_DELAY > 0
-    // Some hubs, kvm switches, and monitors do
-    // weird things, with USB device state bouncing
-    // around wildly on wakeup, yielding race
-    // conditions that can corrupt the keyboard state.
-    //
-    // Pause for a while to let things settle...
-    wait_ms(USB_SUSPEND_WAKEUP_DELAY);
+    osalSysLock();
+    /* If clocks are gated off, turn them back on (may be the case if
+     coming out of suspend mode).*/
+    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
+        /* Set to zero to un-gate the USB core clocks.*/
+        otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
+    }
+    _usb_wakeup(usbp);
+    osalSysUnlock();
 #endif
+}

+__attribute__((weak)) void usb_start(USBDriver *usbp) {
     usbStart(usbp, &usbcfg);
     usbConnectBus(usbp);
 }
diff --git a/tmk_core/protocol/chibios/usb_main.h b/tmk_core/protocol/chibios/usb_main.h
index fb33c8cd0f..d1b8cec671 100644
--- a/tmk_core/protocol/chibios/usb_main.h
+++ b/tmk_core/protocol/chibios/usb_main.h
@@ -34,8 +34,11 @@
 /* Initialize the USB driver and bus */
 void init_usb_driver(USBDriver *usbp);

-/* Restart the USB driver and bus */
-void restart_usb_driver(USBDriver *usbp);
+/* Wakeup the USB driver */
+void usb_wakeup(USBDriver *usbp);
+
+/* Start the USB driver */
+void usb_start(USBDriver *usbp);

 /* ---------------
  * USB Event queue
diff --git a/tmk_core/protocol/host.h b/tmk_core/protocol/host.h
index 6b15f0d0c1..782f3fd70d 100644
--- a/tmk_core/protocol/host.h
+++ b/tmk_core/protocol/host.h
@@ -35,6 +35,7 @@ extern "C" {

 extern uint8_t keyboard_idle;
 extern uint8_t keyboard_protocol;
+extern uint8_t bluetooth_report_protocol;

 /* host driver */
 void           host_set_driver(host_driver_t *driver);
diff --git a/tmk_core/protocol/report.c b/tmk_core/protocol/report.c
index 5755098c60..9922e835be 100644
--- a/tmk_core/protocol/report.c
+++ b/tmk_core/protocol/report.c
@@ -20,6 +20,9 @@
 #include "debug.h"
 #include "util.h"
 #include <string.h>
+#ifdef BLUETOOTH_ENABLE
+#include "transport.h"
+#endif

 #ifdef RING_BUFFERED_6KRO_REPORT_ENABLE
 #    define RO_ADD(a, b) ((a + b) % KEYBOARD_REPORT_KEYS)
@@ -40,7 +43,14 @@ uint8_t has_anykey(report_keyboard_t* keyboard_report) {
     uint8_t* p   = keyboard_report->keys;
     uint8_t  lp  = sizeof(keyboard_report->keys);
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
+
         p  = keyboard_report->nkro.bits;
         lp = sizeof(keyboard_report->nkro.bits);
     }
@@ -57,7 +67,13 @@ uint8_t has_anykey(report_keyboard_t* keyboard_report) {
  */
 uint8_t get_first_key(report_keyboard_t* keyboard_report) {
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         uint8_t i = 0;
         for (; i < KEYBOARD_REPORT_BITS && !keyboard_report->nkro.bits[i]; i++)
             ;
@@ -88,7 +104,13 @@ bool is_key_pressed(report_keyboard_t* keyboard_report, uint8_t key) {
         return false;
     }
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         if ((key >> 3) < KEYBOARD_REPORT_BITS) {
             return keyboard_report->nkro.bits[key >> 3] & 1 << (key & 7);
         } else {
@@ -242,7 +264,13 @@ void del_key_bit(report_keyboard_t* keyboard_report, uint8_t code) {
  */
 void add_key_to_report(report_keyboard_t* keyboard_report, uint8_t key) {
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         add_key_bit(keyboard_report, key);
         return;
     }
@@ -256,7 +284,13 @@ void add_key_to_report(report_keyboard_t* keyboard_report, uint8_t key) {
  */
 void del_key_from_report(report_keyboard_t* keyboard_report, uint8_t key) {
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         del_key_bit(keyboard_report, key);
         return;
     }
@@ -271,7 +305,13 @@ void del_key_from_report(report_keyboard_t* keyboard_report, uint8_t key) {
 void clear_keys_from_report(report_keyboard_t* keyboard_report) {
     // not clear mods
 #ifdef NKRO_ENABLE
+#ifdef  BLUETOOTH_ENABLE
+    if ((((get_transport() == TRANSPORT_USB) && keyboard_protocol) ||
+          ((get_transport() == TRANSPORT_BLUETOOTH) && bluetooth_report_protocol))
+          && keymap_config.nkro) {
+#else
     if (keyboard_protocol && keymap_config.nkro) {
+#endif
         memset(keyboard_report->nkro.bits, 0, sizeof(keyboard_report->nkro.bits));
         return;
     }
