diff --git a/builddefs/common_features.mk b/builddefs/common_features.mk
index a23b5e82b9..66cc4ce40f 100644
--- a/builddefs/common_features.mk
+++ b/builddefs/common_features.mk
@@ -908,3 +908,8 @@ ifeq ($(strip $(ENCODER_ENABLE)), yes)
         OPT_DEFS += -DENCODER_MAP_ENABLE
     endif
 endif
+
+ifeq ($(strip $(RADIAL_CONTROLLER_ENABLE)), yes)
+    SRC += $(QUANTUM_DIR)/radial_controller.c
+    OPT_DEFS += -DRADIAL_CONTROLLER_ENABLE
+endif
diff --git a/quantum/keyboard.c b/quantum/keyboard.c
index 1c62a43d9d..f3f7ed34e9 100644
--- a/quantum/keyboard.c
+++ b/quantum/keyboard.c
@@ -576,6 +576,10 @@ void quantum_task(void) {
 #ifdef SECURE_ENABLE
     secure_task();
 #endif
+
+#ifdef RADIAL_CONTROLLER_ENABLE
+    radial_controller_task();
+#endif
 }
 
 /** \brief Main task that is repeatedly called as fast as possible. */
diff --git a/quantum/quantum.h b/quantum/quantum.h
index 8d74f2be38..4007593997 100644
--- a/quantum/quantum.h
+++ b/quantum/quantum.h
@@ -235,6 +235,10 @@ extern layer_state_t layer_state;
 #    include "process_caps_word.h"
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+#   include "radial_controller.h"
+#endif
+
 // For tri-layer
 void          update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3);
 layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3);
diff --git a/quantum/radial_controller.c b/quantum/radial_controller.c
new file mode 100644
index 0000000000..e7fdba2f4e
--- /dev/null
+++ b/quantum/radial_controller.c
@@ -0,0 +1,109 @@
+/* Copyright 2022 zhaqian
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "radial_controller.h"
+#include "report.h"
+#include "host.h"
+
+// support encoder and switches
+#ifndef RADIAL_CONTROLLER_RESOLUTION
+#define RADIAL_CONTROLLER_RESOLUTION 100
+#endif
+
+#ifndef RADIAL_CONTROLLER_ROTATION_STEP
+#define RADIAL_CONTROLLER_ROTATION_STEP 10
+#endif
+
+#ifndef RADIAL_CONTROLLER_TIMER_DELAY
+#define RADIAL_CONTROLLER_TIMER_DELAY 15
+#endif
+
+#ifndef RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP
+#define RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP RADIAL_CONTROLLER_RESOLUTION
+#endif
+
+static report_radial_controller_t radial_controller_report;
+
+static int16_t radial_controller_rotation = 0;
+static bool is_radial_controller_rotate_finished = true;
+static bool is_clockwise = true;
+static uint16_t radial_controller_timer = 0;
+
+void radial_controller_task(void) {
+	if (!is_radial_controller_rotate_finished) {
+        if (timer_elapsed(radial_controller_timer) > RADIAL_CONTROLLER_TIMER_DELAY) {
+            if (is_clockwise) {
+                radial_controller_rotation = radial_controller_rotation > (3600 - RADIAL_CONTROLLER_ROTATION_STEP) ? \
+                                        3600 : radial_controller_rotation + RADIAL_CONTROLLER_ROTATION_STEP;
+            } else {
+                radial_controller_rotation = radial_controller_rotation < (-(3600 - RADIAL_CONTROLLER_ROTATION_STEP)) ? \
+                                        -3600 : radial_controller_rotation - RADIAL_CONTROLLER_ROTATION_STEP;
+            }
+            radial_controller_timer = timer_read();
+#ifdef RADIAL_CONTROLLER_ROTATION_CONTINUE_BUTTON_ENABLE
+            if (radial_controller_rotation >= RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP \
+                || radial_controller_rotation <= -RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP) {
+                radial_controller_dial_finished();
+                is_radial_controller_rotate_finished = false;
+            }
+#endif
+        }
+    }
+}
+
+void host_radial_controller_send(uint16_t report) {
+    if (!host_get_driver()) return;
+    (host_get_driver()->send_radial)(report);
+}
+
+void radial_controller_event_finished(void) {
+    radial_controller_report.raw = 0;
+    host_radial_controller_send(radial_controller_report.raw);
+}
+
+void radial_controller_button_update(bool pressed) {
+    if (pressed) {
+        radial_controller_report.button = 1;
+    } else {
+        radial_controller_report.raw = 0;
+    }
+    host_radial_controller_send(radial_controller_report.raw);
+}
+
+void radial_controller_dial_update(bool clockwise, bool continued) {
+    if (!continued) {
+        if (clockwise) {
+            radial_controller_report.dial = RADIAL_CONTROLLER_RESOLUTION;
+        } else {
+            radial_controller_report.dial = -RADIAL_CONTROLLER_RESOLUTION;
+        }
+        host_radial_controller_send(radial_controller_report.raw);
+        radial_controller_report.dial = 0;
+    } else {
+        is_clockwise = clockwise;
+        is_radial_controller_rotate_finished = false;
+        radial_controller_timer = timer_read();
+    }
+}
+
+void radial_controller_dial_finished(void) {
+    is_radial_controller_rotate_finished = true;
+    radial_controller_report.dial = radial_controller_rotation;
+    host_radial_controller_send(radial_controller_report.raw);
+    radial_controller_report.dial = 0;
+    radial_controller_rotation = 0;
+    radial_controller_timer = 0;
+}
diff --git a/quantum/radial_controller.h b/quantum/radial_controller.h
new file mode 100644
index 0000000000..4910e9c665
--- /dev/null
+++ b/quantum/radial_controller.h
@@ -0,0 +1,34 @@
+/* Copyright 2022 zhaqian
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include "quantum.h"
+
+typedef union {
+    uint16_t raw;
+    struct __attribute__ ((packed)) {
+        uint16_t button : 1;
+        int16_t dial : 15;
+    };
+} report_radial_controller_t;
+
+void radial_controller_task(void);
+void host_radial_controller_send(uint16_t report);
+void radial_controller_event_finished(void);
+void radial_controller_button_update(bool pressed);
+void radial_controller_dial_update(bool clockwise, bool continued);
+void radial_controller_dial_finished(void);
diff --git a/tmk_core/protocol/chibios/chibios.c b/tmk_core/protocol/chibios/chibios.c
index c9a480c325..6ef254dd75 100644
--- a/tmk_core/protocol/chibios/chibios.c
+++ b/tmk_core/protocol/chibios/chibios.c
@@ -60,11 +60,12 @@ void    send_keyboard(report_keyboard_t *report);
 void    send_mouse(report_mouse_t *report);
 void    send_system(uint16_t data);
 void    send_consumer(uint16_t data);
+void    send_radial(uint16_t data);
 void    send_programmable_button(uint32_t data);
 void    send_digitizer(report_digitizer_t *report);
 
 /* host struct */
-host_driver_t chibios_driver = {keyboard_leds, send_keyboard, send_mouse, send_system, send_consumer, send_programmable_button};
+host_driver_t chibios_driver = {keyboard_leds, send_keyboard, send_mouse, send_system, send_consumer, send_radial, send_programmable_button};
 
 #ifdef VIRTSER_ENABLE
 void virtser_task(void);
diff --git a/tmk_core/protocol/chibios/usb_main.c b/tmk_core/protocol/chibios/usb_main.c
index eb9ef82554..983fae5b81 100644
--- a/tmk_core/protocol/chibios/usb_main.c
+++ b/tmk_core/protocol/chibios/usb_main.c
@@ -985,6 +985,33 @@ void send_consumer(uint16_t data) {
 #endif
 }
 
+void send_radial(uint16_t data) {
+#ifdef RADIAL_CONTROLLER_ENABLE
+    osalSysLock();
+    if (usbGetDriverStateI(&USB_DRIVER) != USB_ACTIVE) {
+        osalSysUnlock();
+        return;
+    }
+
+    if (usbGetTransmitStatusI(&USB_DRIVER, SHARED_IN_EPNUM)) {
+        /* Need to either suspend, or loop and call unlock/lock during
+         * every iteration - otherwise the system will remain locked,
+         * no interrupts served, so USB not going through as well.
+         * Note: for suspend, need USB_USE_WAIT == TRUE in halconf.h */
+        if (osalThreadSuspendTimeoutS(&(&USB_DRIVER)->epc[SHARED_IN_EPNUM]->in_state->thread, TIME_MS2I(10)) == MSG_TIMEOUT) {
+            osalSysUnlock();
+            return;
+        }
+    }
+
+    static report_radial_t report;
+    report = (report_radial_t){.report_id = REPORT_ID_RADIAL, .usage = data};
+
+    usbStartTransmitI(&USB_DRIVER, SHARED_IN_EPNUM, (uint8_t *)&report, sizeof(report_radial_t));
+    osalSysUnlock();
+#endif
+}
+
 void send_programmable_button(uint32_t data) {
 #ifdef PROGRAMMABLE_BUTTON_ENABLE
     osalSysLock();
diff --git a/tmk_core/protocol/host_driver.h b/tmk_core/protocol/host_driver.h
index affd0dcb34..fabd6e83e0 100644
--- a/tmk_core/protocol/host_driver.h
+++ b/tmk_core/protocol/host_driver.h
@@ -29,7 +29,8 @@ typedef struct {
     void (*send_mouse)(report_mouse_t *);
     void (*send_system)(uint16_t);
     void (*send_consumer)(uint16_t);
+    void (*send_radial)(uint16_t);
     void (*send_programmable_button)(uint32_t);
 } host_driver_t;
 
-void send_digitizer(report_digitizer_t *report);
\ No newline at end of file
+void send_digitizer(report_digitizer_t *report);
diff --git a/tmk_core/protocol/lufa/lufa.c b/tmk_core/protocol/lufa/lufa.c
index b4b03357a3..098469903f 100644
--- a/tmk_core/protocol/lufa/lufa.c
+++ b/tmk_core/protocol/lufa/lufa.c
@@ -102,9 +102,10 @@ static uint8_t keyboard_leds(void);
 static void    send_keyboard(report_keyboard_t *report);
 static void    send_mouse(report_mouse_t *report);
 static void    send_system(uint16_t data);
+static void    send_radial(uint16_t data);
 static void    send_consumer(uint16_t data);
 static void    send_programmable_button(uint32_t data);
-host_driver_t  lufa_driver = {keyboard_leds, send_keyboard, send_mouse, send_system, send_consumer, send_programmable_button};
+host_driver_t  lufa_driver = {keyboard_leds, send_keyboard, send_mouse, send_system, send_consumer, send_radial, send_programmable_button};
 
 #ifdef VIRTSER_ENABLE
 // clang-format off
@@ -764,6 +765,14 @@ static void send_system(uint16_t data) {
 #endif
 }
 
+static void send_radial(uint16_t data) {
+#ifdef RADIAL_CONTROLLER_ENABLE
+    static report_radial_t r;
+    r = (report_radial_t){.report_id = REPORT_ID_RADIAL, .usage = data};
+    send_report(&r, sizeof(r));
+#endif
+}
+
 /** \brief Send Consumer
  *
  * FIXME: Needs doc
diff --git a/tmk_core/protocol/report.h b/tmk_core/protocol/report.h
index 735ccdb4a1..801d401efb 100644
--- a/tmk_core/protocol/report.h
+++ b/tmk_core/protocol/report.h
@@ -29,6 +29,7 @@ enum hid_report_ids {
     REPORT_ID_MOUSE,
     REPORT_ID_SYSTEM,
     REPORT_ID_CONSUMER,
+    REPORT_ID_RADIAL,
     REPORT_ID_PROGRAMMABLE_BUTTON,
     REPORT_ID_NKRO,
     REPORT_ID_JOYSTICK,
@@ -196,6 +197,11 @@ typedef struct {
     uint16_t usage;
 } __attribute__((packed)) report_extra_t;
 
+typedef struct {
+    uint8_t  report_id;
+    uint16_t usage;
+} __attribute__((packed)) report_radial_t;
+
 typedef struct {
     uint8_t  report_id;
     uint32_t usage;
diff --git a/tmk_core/protocol/usb_descriptor.c b/tmk_core/protocol/usb_descriptor.c
index 52e3276d35..c796219551 100644
--- a/tmk_core/protocol/usb_descriptor.c
+++ b/tmk_core/protocol/usb_descriptor.c
@@ -250,6 +250,37 @@ const USB_Descriptor_HIDReport_Datatype_t PROGMEM SharedReport[] = {
     HID_RI_END_COLLECTION(0),
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+    HID_RI_USAGE_PAGE(8, 0x01),             // Generic Desktop
+    HID_RI_USAGE(8, 0x0E),                  // System Multi-Axis Controller
+    HID_RI_COLLECTION(8, 0x01),             // Application
+        HID_RI_REPORT_ID(8, REPORT_ID_RADIAL),
+        HID_RI_USAGE_PAGE(8, 0x0D),
+        HID_RI_USAGE(8, 0x21),              // Puck
+        HID_RI_COLLECTION(8, 0x00),         // Physical
+            HID_RI_USAGE_PAGE(8, 0x09),     // Buttons
+            HID_RI_USAGE(8, 0x01),          // Button 1
+            HID_RI_LOGICAL_MINIMUM(8, 0x00),
+            HID_RI_LOGICAL_MAXIMUM(8, 0x01),
+            HID_RI_REPORT_COUNT(8, 1),
+            HID_RI_REPORT_SIZE(8, 1),
+            HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
+
+            HID_RI_USAGE_PAGE(8, 0x01),     // Generic Desktop
+            HID_RI_USAGE(8, 0x37),          // Dial
+            HID_RI_UNIT_EXPONENT(8, 0x0F),
+            HID_RI_UNIT(8, 0x14),
+            HID_RI_PHYSICAL_MINIMUM(16, 0xF1F0),
+            HID_RI_PHYSICAL_MAXIMUM(16, 0x0E10),
+            HID_RI_LOGICAL_MINIMUM(16, 0xF1F0),
+            HID_RI_LOGICAL_MAXIMUM(16, 0x0E10),
+            HID_RI_REPORT_COUNT(8, 1),
+            HID_RI_REPORT_SIZE(8, 15),
+            HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_RELATIVE),
+        HID_RI_END_COLLECTION(0),
+    HID_RI_END_COLLECTION(0),
+#endif
+
 #ifdef PROGRAMMABLE_BUTTON_ENABLE
     HID_RI_USAGE_PAGE(8, 0x0C),            // Consumer
     HID_RI_USAGE(8, 0x01),                 // Consumer Control
