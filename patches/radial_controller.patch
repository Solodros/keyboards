diff --git a/builddefs/common_features.mk b/builddefs/common_features.mk
index a23b5e82..66cc4ce4 100644
--- a/builddefs/common_features.mk
+++ b/builddefs/common_features.mk
@@ -908,3 +908,8 @@ ifeq ($(strip $(ENCODER_ENABLE)), yes)
         OPT_DEFS += -DENCODER_MAP_ENABLE
     endif
 endif
+
+ifeq ($(strip $(RADIAL_CONTROLLER_ENABLE)), yes)
+    SRC += $(QUANTUM_DIR)/radial_controller.c
+    OPT_DEFS += -DRADIAL_CONTROLLER_ENABLE
+endif
diff --git a/quantum/keyboard.c b/quantum/keyboard.c
index 1c62a43d..f3f7ed34 100644
--- a/quantum/keyboard.c
+++ b/quantum/keyboard.c
@@ -576,6 +576,10 @@ void quantum_task(void) {
 #ifdef SECURE_ENABLE
     secure_task();
 #endif
+
+#ifdef RADIAL_CONTROLLER_ENABLE
+    radial_controller_task();
+#endif
 }
 
 /** \brief Main task that is repeatedly called as fast as possible. */
diff --git a/quantum/quantum.h b/quantum/quantum.h
index 8d74f2be..40075939 100644
--- a/quantum/quantum.h
+++ b/quantum/quantum.h
@@ -235,6 +235,10 @@ extern layer_state_t layer_state;
 #    include "process_caps_word.h"
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+#   include "radial_controller.h"
+#endif
+
 // For tri-layer
 void          update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3);
 layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3);
diff --git a/quantum/radial_controller.c b/quantum/radial_controller.c
new file mode 100644
index 00000000..b1732e4e
--- /dev/null
+++ b/quantum/radial_controller.c
@@ -0,0 +1,104 @@
+/* Copyright 2022 zhaqian
+ * Modified 2022 masasfumi
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "radial_controller.h"
+#include "report.h"
+
+// support encoder and switches
+#ifndef RADIAL_CONTROLLER_RESOLUTION
+#define RADIAL_CONTROLLER_RESOLUTION 100
+#endif
+
+#ifndef RADIAL_CONTROLLER_ROTATION_STEP
+#define RADIAL_CONTROLLER_ROTATION_STEP 10
+#endif
+
+#ifndef RADIAL_CONTROLLER_TIMER_DELAY
+#define RADIAL_CONTROLLER_TIMER_DELAY 15
+#endif
+
+#ifndef RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP
+#define RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP RADIAL_CONTROLLER_RESOLUTION
+#endif
+
+static report_radial_controller_t radial_controller_report;
+
+static int16_t radial_controller_rotation = 0;
+static bool is_radial_controller_rotate_finished = true;
+static bool is_clockwise = true;
+static uint16_t radial_controller_timer = 0;
+
+void radial_controller_task(void) {
+	if (!is_radial_controller_rotate_finished) {
+        if (timer_elapsed(radial_controller_timer) > RADIAL_CONTROLLER_TIMER_DELAY) {
+            if (is_clockwise) {
+                radial_controller_rotation = radial_controller_rotation > (3600 - RADIAL_CONTROLLER_ROTATION_STEP) ? \
+                                        3600 : radial_controller_rotation + RADIAL_CONTROLLER_ROTATION_STEP;
+            } else {
+                radial_controller_rotation = radial_controller_rotation < (-(3600 - RADIAL_CONTROLLER_ROTATION_STEP)) ? \
+                                        -3600 : radial_controller_rotation - RADIAL_CONTROLLER_ROTATION_STEP;
+            }
+            radial_controller_timer = timer_read();
+#ifdef RADIAL_CONTROLLER_ROTATION_CONTINUE_BUTTON_ENABLE
+            if (radial_controller_rotation >= RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP \
+                || radial_controller_rotation <= -RADIAL_CONTROLLER_ROTATION_CONTINUE_STEP) {
+                radial_controller_dial_finished();
+                is_radial_controller_rotate_finished = false;
+            }
+#endif
+        }
+    }
+}
+
+void radial_controller_event_finished(void) {
+    radial_controller_report.raw = 0;
+    host_radial_controller_send(&radial_controller_report);
+}
+
+void radial_controller_button_update(bool pressed) {
+    if (pressed) {
+        radial_controller_report.button = 1;
+    } else {
+        radial_controller_report.raw = 0;
+    }
+    host_radial_controller_send(&radial_controller_report);
+}
+
+void radial_controller_dial_update(bool clockwise, bool continued) {
+    if (!continued) {
+        if (clockwise) {
+            radial_controller_report.dial = RADIAL_CONTROLLER_RESOLUTION;
+        } else {
+            radial_controller_report.dial = -RADIAL_CONTROLLER_RESOLUTION;
+        }
+        host_radial_controller_send(&radial_controller_report);
+        radial_controller_report.dial = 0;
+    } else {
+        is_clockwise = clockwise;
+        is_radial_controller_rotate_finished = false;
+        radial_controller_timer = timer_read();
+    }
+}
+
+void radial_controller_dial_finished(void) {
+    is_radial_controller_rotate_finished = true;
+    radial_controller_report.dial = radial_controller_rotation;
+    host_radial_controller_send(&radial_controller_report);
+    radial_controller_report.dial = 0;
+    radial_controller_rotation = 0;
+    radial_controller_timer = 0;
+}
diff --git a/quantum/radial_controller.h b/quantum/radial_controller.h
new file mode 100644
index 00000000..8f097411
--- /dev/null
+++ b/quantum/radial_controller.h
@@ -0,0 +1,27 @@
+/* Copyright 2022 zhaqian
+ * Modified 2022 masafumi
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include "quantum.h"
+
+void host_radial_controller_send(report_radial_controller_t *report);
+void radial_controller_task(void);
+void radial_controller_event_finished(void);
+void radial_controller_button_update(bool pressed);
+void radial_controller_dial_update(bool clockwise, bool continued);
+void radial_controller_dial_finished(void);
diff --git a/tmk_core/protocol/chibios/usb_main.c b/tmk_core/protocol/chibios/usb_main.c
index eb9ef825..7e7d6e92 100644
--- a/tmk_core/protocol/chibios/usb_main.c
+++ b/tmk_core/protocol/chibios/usb_main.c
@@ -322,6 +322,9 @@ typedef struct {
 #ifdef JOYSTICK_ENABLE
             usb_driver_config_t joystick_driver;
 #endif
+#ifdef RADIAL_CONTROLLER_ENABLE
+            usb_driver_config_t radial_controller_driver;
+#endif
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
             usb_driver_config_t digitizer_driver;
 #endif
@@ -374,6 +377,14 @@ static usb_driver_configs_t drivers = {
     .joystick_driver = QMK_USB_DRIVER_CONFIG(JOYSTICK, 0, false),
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+#    define RADIAL_CONTROLLER_IN_CAPACITY 4
+#    define RADIAL_CONTROLLER_OUT_CAPACITY 4
+#    define RADIAL_CONTROLLER_IN_MODE USB_EP_MODE_TYPE_BULK
+#    define RADIAL_CONTROLLER_OUT_MODE USB_EP_MODE_TYPE_BULK
+    .joystick_driver = QMK_USB_DRIVER_CONFIG(RADIAL_CONTROLLER, 0, false),
+#endif
+
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
 #    define DIGITIZER_IN_CAPACITY 4
 #    define DIGITIZER_OUT_CAPACITY 4
@@ -1031,6 +1042,12 @@ void send_digitizer(report_digitizer_t *report) {
 #endif
 }
 
+void send_radial_controller(report_radial_controller_t *report) {
+#ifdef RADIAL_CONTROLLER_ENABLE
+    chnWrite(&drivers.radial_controller_driver.driver, (uint8_t *)report, sizeof(report_radial_controller_t));
+#endif
+}
+
 /* ---------------------------------------------------------
  *                   Console functions
  * ---------------------------------------------------------
diff --git a/tmk_core/protocol/host.c b/tmk_core/protocol/host.c
index 3d8604d5..85794f9b 100644
--- a/tmk_core/protocol/host.c
+++ b/tmk_core/protocol/host.c
@@ -23,6 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "util.h"
 #include "debug.h"
 #include "digitizer.h"
+#include "radial_controller.h"
 
 #ifdef NKRO_ENABLE
 #    include "keycode_config.h"
@@ -144,6 +145,13 @@ void host_programmable_button_send(uint32_t report) {
     (*driver->send_programmable_button)(report);
 }
 
+void host_radial_controller_send(report_radial_controller_t *report) {
+    if (!driver) return;
+    send_radial_controller(report);
+}
+
+__attribute__((weak)) void send_radial_controller(report_radial_controller_t *report) {}
+
 uint16_t host_last_system_report(void) {
     return last_system_report;
 }
diff --git a/tmk_core/protocol/host_driver.h b/tmk_core/protocol/host_driver.h
index affd0dcb..20c7dd4d 100644
--- a/tmk_core/protocol/host_driver.h
+++ b/tmk_core/protocol/host_driver.h
@@ -32,4 +32,5 @@ typedef struct {
     void (*send_programmable_button)(uint32_t);
 } host_driver_t;
 
-void send_digitizer(report_digitizer_t *report);
\ No newline at end of file
+void send_radial_controller(report_radial_controller_t *report);
+void send_digitizer(report_digitizer_t *report);
diff --git a/tmk_core/protocol/lufa/lufa.c b/tmk_core/protocol/lufa/lufa.c
index b4b03357..14c00796 100644
--- a/tmk_core/protocol/lufa/lufa.c
+++ b/tmk_core/protocol/lufa/lufa.c
@@ -497,6 +497,11 @@ void EVENT_USB_Device_ConfigurationChanged(void) {
     ConfigSuccess &= Endpoint_ConfigureEndpoint((JOYSTICK_IN_EPNUM | ENDPOINT_DIR_IN), EP_TYPE_INTERRUPT, JOYSTICK_EPSIZE, 1);
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+    /* Setup joystick endpoint */
+    ConfigSuccess &= Endpoint_ConfigureEndpoint((RADIAL_CONTROLLER_IN_EPNUM | ENDPOINT_DIR_IN), EP_TYPE_INTERRUPT, RADIAL_CONTROLLER_EPSIZE, 1);
+#endif
+
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
     /* Setup digitizer endpoint */
     ConfigSuccess &= Endpoint_ConfigureEndpoint((DIGITIZER_IN_EPNUM | ENDPOINT_DIR_IN), EP_TYPE_INTERRUPT, DIGITIZER_EPSIZE, 1);
@@ -980,6 +985,24 @@ void send_digitizer(report_digitizer_t *report) {
 #endif
 }
 
+void send_radial_controller(report_radial_controller_t *report) {
+#ifdef RADIAL_CONTROLLER_ENABLE
+    uint8_t timeout = 255;
+
+    if (USB_DeviceState != DEVICE_STATE_Configured) return;
+
+    Endpoint_SelectEndpoint(RADIAL_CONTROLLER_IN_EPNUM);
+
+    /* Check if write ready for a polling interval around 10ms */
+    while (timeout-- && !Endpoint_IsReadWriteAllowed())
+        _delay_us(40);
+    if (!Endpoint_IsReadWriteAllowed()) return;
+
+    Endpoint_Write_Stream_LE(report, sizeof(report_radial_controller_t), NULL);
+    Endpoint_ClearIN();
+#endif
+}
+
 /*******************************************************************************
  * main
  ******************************************************************************/
diff --git a/tmk_core/protocol/report.h b/tmk_core/protocol/report.h
index 735ccdb4..894ebe0c 100644
--- a/tmk_core/protocol/report.h
+++ b/tmk_core/protocol/report.h
@@ -247,6 +247,14 @@ typedef struct {
 #endif
 } __attribute__((packed)) joystick_report_t;
 
+typedef union {
+    uint16_t raw;
+    struct __attribute__ ((packed)) {
+        uint16_t button : 1;
+        int16_t dial : 15;
+    };
+} report_radial_controller_t;
+
 /* keycode to system usage */
 static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
     switch (key) {
diff --git a/tmk_core/protocol/usb_descriptor.c b/tmk_core/protocol/usb_descriptor.c
index 52e3276d..e99df53d 100644
--- a/tmk_core/protocol/usb_descriptor.c
+++ b/tmk_core/protocol/usb_descriptor.c
@@ -418,6 +418,38 @@ const USB_Descriptor_HIDReport_Datatype_t PROGMEM JoystickReport[] = {
 };
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+const USB_Descriptor_HIDReport_Datatype_t PROGMEM RadialControllerReport[] = {
+    HID_RI_USAGE_PAGE(8, 0x01),             // Generic Desktop
+    HID_RI_USAGE(8, 0x0E),                  // System Multi-Axis Controller
+    HID_RI_COLLECTION(8, 0x01),             // Application
+        HID_RI_USAGE_PAGE(8, 0x0D),
+        HID_RI_USAGE(8, 0x21),              // Puck
+        HID_RI_COLLECTION(8, 0x00),         // Physical
+            HID_RI_USAGE_PAGE(8, 0x09),     // Buttons
+            HID_RI_USAGE(8, 0x01),          // Button 1
+            HID_RI_LOGICAL_MINIMUM(8, 0x00),
+            HID_RI_LOGICAL_MAXIMUM(8, 0x01),
+            HID_RI_REPORT_COUNT(8, 1),
+            HID_RI_REPORT_SIZE(8, 1),
+            HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_ABSOLUTE),
+
+            HID_RI_USAGE_PAGE(8, 0x01),     // Generic Desktop
+            HID_RI_USAGE(8, 0x37),          // Dial
+            HID_RI_UNIT_EXPONENT(8, 0x0F),
+            HID_RI_UNIT(8, 0x14),
+            HID_RI_PHYSICAL_MINIMUM(16, 0xF1F0),
+            HID_RI_PHYSICAL_MAXIMUM(16, 0x0E10),
+            HID_RI_LOGICAL_MINIMUM(16, 0xF1F0),
+            HID_RI_LOGICAL_MAXIMUM(16, 0x0E10),
+            HID_RI_REPORT_COUNT(8, 1),
+            HID_RI_REPORT_SIZE(8, 15),
+            HID_RI_INPUT(8, HID_IOF_DATA | HID_IOF_VARIABLE | HID_IOF_RELATIVE),
+        HID_RI_END_COLLECTION(0),
+    HID_RI_END_COLLECTION(0),
+};
+#endif
+
 /*
  * Device descriptor
  */
@@ -997,6 +1029,46 @@ const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor = {
     }
 #endif
 
+    /*
+     * Radial Controller
+     */
+#ifdef RADIAL_CONTROLLER_ENABLE
+    .RadialController_Interface = {
+        .Header = {
+            .Size               = sizeof(USB_Descriptor_Interface_t),
+            .Type               = DTYPE_Interface
+        },
+        .InterfaceNumber        = RADIAL_CONTROLLER_INTERFACE,
+        .AlternateSetting       = 0x00,
+        .TotalEndpoints         = 1,
+        .Class                  = HID_CSCP_HIDClass,
+        .SubClass               = HID_CSCP_NonBootSubclass,
+        .Protocol               = HID_CSCP_NonBootProtocol,
+        .InterfaceStrIndex      = NO_DESCRIPTOR
+    },
+    .RadialController_HID = {
+        .Header = {
+            .Size               = sizeof(USB_HID_Descriptor_HID_t),
+            .Type               = HID_DTYPE_HID
+        },
+        .HIDSpec                = VERSION_BCD(1, 1, 1),
+        .CountryCode            = 0x00,
+        .TotalReportDescriptors = 1,
+        .HIDReportType          = HID_DTYPE_Report,
+        .HIDReportLength        = sizeof(RadialControllerReport)
+    },
+    .RadialController_INEndpoint = {
+        .Header = {
+            .Size               = sizeof(USB_Descriptor_Endpoint_t),
+            .Type               = DTYPE_Endpoint
+        },
+        .EndpointAddress        = (ENDPOINT_DIR_IN | RADIAL_CONTROLLER_IN_EPNUM),
+        .Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
+        .EndpointSize           = RADIAL_CONTROLLER_EPSIZE,
+        .PollingIntervalMS      = USB_POLLING_INTERVAL_MS
+    }
+#endif
+
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
     /*
      * Digitizer
@@ -1174,6 +1246,12 @@ uint16_t get_usb_descriptor(const uint16_t wValue, const uint16_t wIndex, const
                     Size    = sizeof(USB_HID_Descriptor_HID_t);
                     break;
 #endif
+#ifdef RADIAL_CONTROLLER_ENABLE
+                case RADIAL_CONTROLLER_INTERFACE:
+                    Address = &ConfigurationDescriptor.RadialController_HID;
+                    Size    = sizeof(USB_HID_Descriptor_HID_t);
+                    break;
+#endif
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
                 case DIGITIZER_INTERFACE:
                     Address = &ConfigurationDescriptor.Digitizer_HID;
@@ -1231,6 +1309,12 @@ uint16_t get_usb_descriptor(const uint16_t wValue, const uint16_t wIndex, const
                     Size    = sizeof(JoystickReport);
                     break;
 #endif
+#ifdef RADIAL_CONTROLLER_ENABLE
+                case RADIAL_CONTROLLER_INTERFACE:
+                    Address = &RadialControllerReport;
+                    Size    = sizeof(RadialControllerReport);
+                    break;
+#endif
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
                 case DIGITIZER_INTERFACE:
                     Address = &DigitizerReport;
diff --git a/tmk_core/protocol/usb_descriptor.h b/tmk_core/protocol/usb_descriptor.h
index f8b7a863..ad24a000 100644
--- a/tmk_core/protocol/usb_descriptor.h
+++ b/tmk_core/protocol/usb_descriptor.h
@@ -139,6 +139,13 @@ typedef struct {
     USB_Descriptor_Endpoint_t  Joystick_INEndpoint;
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+    // Joystick HID Interface
+    USB_Descriptor_Interface_t RadialController_Interface;
+    USB_HID_Descriptor_HID_t   RadialController_HID;
+    USB_Descriptor_Endpoint_t  RadialController_INEndpoint;
+#endif
+
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
     // Digitizer HID Interface
     USB_Descriptor_Interface_t Digitizer_Interface;
@@ -191,6 +198,10 @@ enum usb_interfaces {
     JOYSTICK_INTERFACE,
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+    RADIAL_CONTROLLER_INTERFACE,
+#endif
+
 #if defined(DIGITIZER_ENABLE) && !defined(DIGITIZER_SHARED_EP)
     DIGITIZER_INTERFACE,
 #endif
@@ -274,6 +285,15 @@ enum usb_endpoints {
 #    endif
 #endif
 
+#ifdef RADIAL_CONTROLLER_ENABLE
+    RADIAL_CONTROLLER_IN_EPNUM = NEXT_EPNUM,
+#    ifdef USB_ENDPOINTS_ARE_REORDERABLE
+    RADIAL_CONTROLLER_OUT_EPNUM = RADIAL_CONTROLLER_IN_EPNUM,
+#    else
+    RADIAL_CONTROLLER_EPNUM    = NEXT_EPNUM,
+#    endif
+#endif
+
 #ifdef DIGITIZER_ENABLE
 #    if !defined(DIGITIZER_SHARED_EP)
     DIGITIZER_IN_EPNUM = NEXT_EPNUM,
@@ -311,6 +331,7 @@ enum usb_endpoints {
 #define CDC_NOTIFICATION_EPSIZE 8
 #define CDC_EPSIZE 16
 #define JOYSTICK_EPSIZE 8
+#define RADIAL_CONTROLLER_EPSIZE 8
 #define DIGITIZER_EPSIZE 8
 
 uint16_t get_usb_descriptor(const uint16_t wValue, const uint16_t wIndex, const void** const DescriptorAddress);
